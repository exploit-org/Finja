package org.exploit.evm.address;

import org.exploit.crypto.utils.Pair;
import org.exploit.finja.core.OutgoingTransaction;
import org.exploit.finja.core.SmartCoinBalanceService;
import org.exploit.finja.core.SmartContractWallet;
import org.exploit.finja.core.constant.AmountUnit;
import org.exploit.finja.core.constant.Flag;
import org.exploit.finja.core.contract.SolidityContract;
import org.exploit.finja.core.contract.transaction.ContractCall;
import org.exploit.finja.core.key.ECKeyManager;
import org.exploit.finja.core.model.Amount;
import org.exploit.finja.core.model.Recipient;
import org.exploit.finja.core.model.Value;
import org.exploit.evm.EvmProvider;
import org.exploit.evm.contract.EthMultiTransferContract;
import org.exploit.evm.protocol.EthCall;
import org.exploit.evm.service.TransactionService;
import org.web3j.abi.datatypes.Address;
import org.web3j.abi.datatypes.DynamicArray;
import org.web3j.abi.datatypes.Type;
import org.web3j.abi.datatypes.generated.Uint256;

import java.math.BigInteger;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

public class EvmWallet implements SmartContractWallet {
    protected final EvmProvider provider;

    protected final String address;

    protected final TransactionService transactions;
    protected final SmartCoinBalanceService balanceService;

    protected final List<SolidityContract> contracts;

    public EvmWallet(EvmProvider provider, String address, ECKeyManager keyManager) {
        this.provider = provider;
        this.address = address;

        this.transactions = new TransactionService(provider, keyManager);

        this.balanceService = provider.balanceService();
        this.contracts = provider.getContractRegistry();
    }

    @Override
    public OutgoingTransaction transaction(String to, Amount amount, int flags) {
        return transactions.sendTransaction(address, to, amount, flags);
    }

    @Override
    public OutgoingTransaction transaction(String to, String contractAddress, Amount amount) {
        return transactions.sendTransaction(address, to, contractAddress, amount);
    }

    @Override
    public OutgoingTransaction transaction(List<Recipient> recipients, int flags) {
        var multiTransferContract = provider.findContract(EthMultiTransferContract.class);

        if (multiTransferContract == null)
            throw new IllegalStateException("MultiTransfer contract not specified");

        var addresses = recipients.stream()
                .map(r -> new Address(r.getAddress()))
                .toList();

        var amountsList = recipients.stream()
                .map(r -> new Uint256(r.getAmount().asUnit(provider)))
                .toList();

        if ((flags & Flag.INCLUDE_FEE) == 0) {
            return callMultiTransferContract(multiTransferContract, addresses, amountsList);
        }

        return adjustAmountsForFee(multiTransferContract, addresses, amountsList);
    }

    private OutgoingTransaction callMultiTransferContract(
            SolidityContract multiTransferContract,
            List<Address> addresses,
            List<Uint256> amountsList
    ) {
        return multiTransferContract.execute(this, "send", List.of(
                new DynamicArray<>(addresses),
                new DynamicArray<>(amountsList)
        ));
    }

    private OutgoingTransaction adjustAmountsForFee(
            SolidityContract multiTransferContract,
            List<Address> addresses,
            List<Uint256> amountsList
    ) {
        var callObject = (EthCall) multiTransferContract.call(this, "send", List.of(
                    new DynamicArray<>(addresses),
                    new DynamicArray<>(amountsList))
        );

        var totalFee = estimateTotalFee(callObject);

        return callMultiTransferContract(multiTransferContract, addresses, calculateAdjustedAmounts(amountsList, totalFee));
    }

    private BigInteger estimateTotalFee(EthCall callObject) {
        var gasEstimate = provider.client().estimateGas(callObject);
        var averageGasPrice = provider.client().getAverageGasPrice();

        return gasEstimate.multiply(averageGasPrice);
    }

    private List<Uint256> calculateAdjustedAmounts(List<Uint256> amountsList, BigInteger totalFee) {
        var totalAmount = amountsList.stream()
                .map(Uint256::getValue)
                .reduce(BigInteger.ZERO, BigInteger::add);

        return amountsList.stream()
                .map(amount -> {
                    var feeShare = amount.getValue().multiply(totalFee).divide(totalAmount);
                    var newAmount = amount.getValue().subtract(feeShare);

                    if (newAmount.compareTo(BigInteger.ZERO) <= 0) {
                        throw new IllegalArgumentException("Adjustment results in zero or negative amount for recipient");
                    }

                    return new Uint256(newAmount);
                })
                .toList();
    }

    @Override
    public OutgoingTransaction transaction(String contractAddress, List<Recipient> recipients) {
        var multiTransferContract = provider.findContract(EthMultiTransferContract.class);

        if (multiTransferContract == null)
            throw new IllegalStateException("MultiTransfer contract not specified");

        var recipientMap = recipients.stream().collect(Collectors.toMap(Recipient::getAddress, Recipient::getAmount));

        var pairs = recipientMap.entrySet().stream()
                .map(entry -> {
                    var address = new Address(entry.getKey());
                    var amount = entry.getValue();

                    if (amount.amountUnit() == AmountUnit.HUMAN) {
                        var unitAmount = new Uint256(provider.converter().toUnit(amount.value(), contractAddress));
                        return Pair.of(address, unitAmount);
                    }

                    return Pair.of(address, new Uint256(amount.value().toBigInteger()));
                })
                .toList();

        var receivers = new DynamicArray<>(pairs.stream().map(Pair::first).toList());
        var amounts = new DynamicArray<>(pairs.stream().map(Pair::second).toList());

        return multiTransferContract.execute(this, "sendToken", List.of(
                new Address(contractAddress), receivers, amounts
        ));
    }

    @Override
    public OutgoingTransaction execute(Class<SolidityContract> contract, String functionName, List<Type> args) {
        return Optional.ofNullable(provider.findContract(contract))
                .map(c -> c.execute(this, functionName, args))
                .orElseThrow(() -> new IllegalArgumentException("Contract not found: " + contract.getName()));
    }

    @Override
    public ContractCall call(Class<SolidityContract> contract, String functionName, List<Type> args) {
        return Optional.ofNullable(provider.findContract(contract))
                .map(c -> c.call(this, functionName, args))
                .orElseThrow(() -> new IllegalArgumentException("Contract not found: " + contract.getName()));
    }

    @Override
    public Value balance() {
        return balanceService.balance(address);
    }

    public TransactionService transactions() {
        return transactions;
    }

    @Override
    public String publicAddress() {
        return address;
    }

    @Override
    public Value balance(String contractAddress) {
        return balanceService.balance(address, contractAddress);
    }

    @Override
    public void erase() {
        transactions.erase();
    }
}
