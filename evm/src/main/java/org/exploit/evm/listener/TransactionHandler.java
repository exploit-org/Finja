package org.exploit.evm.listener;

import lombok.RequiredArgsConstructor;
import org.exploit.crypto.utils.Pair;
import org.exploit.evm.EvmProvider;
import org.exploit.evm.listener.hook.AddressHook;
import org.exploit.evm.listener.hook.AddressHookRegistry;
import org.exploit.evm.model.EthTransaction;
import org.exploit.finja.core.constant.Asset;
import org.exploit.finja.core.constant.TxType;
import org.exploit.finja.core.event.TxnEvent;
import org.exploit.finja.core.model.Value;
import org.exploit.finja.utils.Functions;
import org.exploit.signalix.manager.EventScope;
import org.web3j.utils.Numeric;
import reactor.core.publisher.Mono;

import java.math.BigInteger;
import java.util.Map;

@RequiredArgsConstructor
public class TransactionHandler {
    private final EvmProvider provider;
    private final EventScope eventScope;
    private final AddressHookRegistry registry;

    public Mono<Void> handleTransaction(EthTransaction transaction) {
        return handleSmartContract(transaction)
                .flatMap(result -> result ? Mono.empty() : handleTransfer(transaction));
    }

    public Mono<Void> handleTransfer(EthTransaction transaction) {
        return Mono.justOrEmpty(registry.find(transaction.from()))
                .switchIfEmpty(Mono.justOrEmpty(registry.find(transaction.to())))
                .flatMap(party -> createEvent(party, transaction)
                        .doOnNext(party::addEvent)
                        .flatMap(event -> Mono.fromRunnable(() -> eventScope.call(event)))
                        .then()
                )
                .onErrorResume(t -> Mono.fromRunnable(t::printStackTrace));
    }

    public Mono<Boolean> handleSmartContract(EthTransaction transaction) {
        if (!transaction.input().startsWith(TRANSFER_FUNCTION_PREFIX))
            return Mono.just(false);

        var decodedTransfer = Functions.decodeTransfer(transaction.input());

        if (decodedTransfer == null)
            return Mono.just(false);

        return Mono.justOrEmpty(registry.find(transaction.from()))
                .switchIfEmpty(Mono.justOrEmpty(registry.find(decodedTransfer.first())))
                .flatMap(party -> createSmartContractEvent(party, transaction, decodedTransfer)
                        .doOnNext(party::addEvent)
                        .flatMap(event -> Mono.fromRunnable(() -> eventScope.call(event))
                        .thenReturn(true)
                )
                .switchIfEmpty(Mono.just(false)));
    }

    private Mono<TxnEvent> createEvent(AddressHook party, EthTransaction transaction) {
        var txType = party.getAddress().equals(transaction.from()) ? TxType.SEND : TxType.RECEIVE;

        var unitAmount = Numeric.toBigInt(transaction.value());
        var decimalAmount = provider.converter().toHuman(unitAmount);

        var timestamp = System.currentTimeMillis();

        return Mono.just(TxnEvent.builder()
                .type(txType)
                .asset(Asset.EVM)
                .txid(transaction.hash())
                .address(party.getAddress())
                .value(new Value(decimalAmount, unitAmount))
                .confirmations(0)
                .timestamp(timestamp)
                .meta(Map.of("chainId", transaction.chainId()))
                .build());
    }

    private Mono<Long> timestamp(EthTransaction tx) {
        return Mono.fromCallable(() ->provider.client().getBlockByHash(tx.hash()))
                .map(block -> new BigInteger(block.getTimestamp(), 16))
                .map(BigInteger::longValue);
    }

    private Mono<TxnEvent> createSmartContractEvent(
            AddressHook party,
            EthTransaction transaction,
            Pair<String, BigInteger> decodedTransfer
    ) {
        var recipient = decodedTransfer.first();
        var txType = recipient.equals(party.getAddress()) ? TxType.RECEIVE : TxType.SEND;

        return Mono.fromCallable(() ->provider.converter().toHuman(decodedTransfer.second(), transaction.to()))
                .map(decimalAmount -> new Value(decimalAmount, decodedTransfer.second()))
                .zipWith(timestamp(transaction))
                .map(tuple -> TxnEvent.builder()
                        .type(txType)
                        .asset(Asset.EVM)
                        .txid(transaction.hash())
                        .address(party.getAddress())
                        .value(tuple.getT1())
                        .smartContract(transaction.to())
                        .confirmations(0)
                        .timestamp(tuple.getT2())
                        .meta(Map.of("chainId", transaction.chainId()))
                        .build()
                );
    }

    private static final String TRANSFER_FUNCTION_PREFIX = "0xa9059cbb";
}