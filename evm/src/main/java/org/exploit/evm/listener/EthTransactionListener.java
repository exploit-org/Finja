package org.exploit.evm.listener;

import org.exploit.finja.core.TransactionListener;
import org.exploit.finja.core.constant.Asset;
import org.exploit.finja.core.event.TxnEvent;
import org.exploit.finja.stereotype.Subscriber;
import org.exploit.evm.EvmProvider;
import org.exploit.evm.listener.hook.AddressHook;
import org.exploit.evm.listener.hook.AddressHookRegistry;
import org.exploit.evm.model.EthTransaction;
import org.exploit.evm.model.SubscriptionConfig;
import org.exploit.signalix.manager.EventScope;
import reactor.core.Disposable;
import reactor.core.publisher.Flux;

public class EthTransactionListener implements TransactionListener, Subscriber {
    private final AddressHookRegistry registry = new AddressHookRegistry();

    private final EvmProvider provider;

    private final TransactionHandler txHandler;
    private final ConfirmationHandler confirmHandler;

    private final SubscriptionConfig subscriptionConfig;

    private Disposable txListener;
    private Disposable confirmListener;

    public EthTransactionListener(EvmProvider provider, SubscriptionConfig config, EventScope eventScope) {
        this.provider = provider;

        this.subscriptionConfig = config;
        this.txHandler = new TransactionHandler(provider, eventScope, registry);
        this.confirmHandler = new ConfirmationHandler(provider, eventScope, registry);
    }

    @Override
    public void listen(String address, long timestamp) {
        registry.register(address, timestamp);
    }

    public AddressHook find(String address) {
        return registry.find(address);
    }

    public void handle(EthTransaction transaction) {
        txHandler.handleTransaction(transaction).block();
    }

    @Override
    public void removeListener(String address) {
        registry.unregister(address);
    }

    @Override
    public Flux<TxnEvent> restore(String address, long timestamp) {
        return provider.eventFetcher().events(address, timestamp)
                .collectList()
                .doOnNext(list -> registry.register(address, timestamp, list))
                .flatMapMany(Flux::fromIterable);
    }

    @Override
    public Asset asset() {
        return Asset.EVM;
    }

    @Override
    public void start() {
        this.txListener = provider.client().subscribeTransactions(subscriptionConfig, txHandler::handleTransaction);
        this.confirmListener = provider.client().subscribeBlockHeaders(ignored -> confirmHandler.handleBlocks());
    }

    @Override
    public EthTransactionListener subscribe() {
        start();
        return this;
    }

    @Override
    public void dispose() {
        if (txListener != null)
            txListener.dispose();

        if (confirmListener != null)
            confirmListener.dispose();
    }
}