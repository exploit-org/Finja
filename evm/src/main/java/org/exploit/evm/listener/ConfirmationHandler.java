package org.exploit.evm.listener;

import lombok.RequiredArgsConstructor;
import org.exploit.finja.core.event.TxnCancelledEvent;
import org.exploit.finja.core.event.TxnEvent;
import org.exploit.finja.exception.TransactionNotFoundException;
import org.exploit.evm.EvmProvider;
import org.exploit.evm.listener.hook.AddressHookRegistry;
import org.exploit.signalix.manager.EventScope;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

import java.math.BigInteger;

@RequiredArgsConstructor
public class ConfirmationHandler {
    private final EvmProvider provider;
    private final EventScope eventScope;
    private final AddressHookRegistry registry;

    public Mono<Void> handleBlocks() {
        return Mono.fromCallable(() -> provider.client().currentBlockNumber())
                .flatMap(blockNumber ->
                    Flux.fromIterable(registry.getAddressHooks())
                        .flatMap(hook -> Flux.fromIterable(hook.getEvents()))
                        .flatMap(event -> handleEvent(event, blockNumber))
                        .then()
                );
    }

    private Mono<Void> handleEvent(TxnEvent event, BigInteger blockNumber) {
        return Mono.fromCallable(() -> provider.client().confirmations(event.getTxid(), blockNumber))
                .flatMap(confirmations -> {
                    int intValue = confirmations.intValue();

                    if (event.getConfirmations() == intValue) {
                        return Mono.empty();
                    }

                    event.setConfirmations(intValue);
                    return Mono.fromFuture(eventScope.callAsync(event));
                })
                .onErrorResume(TransactionNotFoundException.class, t -> doubleSpend(event));
    }

    private Mono<Void> doubleSpend(TxnEvent event) {
        registry.unregister(event);
        return Mono.fromFuture(eventScope.callAsync(new TxnCancelledEvent(event)));
    }
}
