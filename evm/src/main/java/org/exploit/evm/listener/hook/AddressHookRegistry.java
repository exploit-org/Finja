package org.exploit.evm.listener.hook;

import org.exploit.finja.core.event.TxnEvent;
import org.exploit.finja.stereotype.Cleanable;

import java.util.HashSet;
import java.util.List;
import java.util.Set;

public class AddressHookRegistry implements Cleanable {
    private final Set<AddressHook> addressHooks = new HashSet<>();

    public void register(String address, long timestamp) {
        if (addressHooks.stream().anyMatch(hook -> hook.getAddress().equals(address)))
            return;

        addressHooks.add(new AddressHook(address, timestamp));
    }

    public void register(String address, long timestamp, List<TxnEvent> events) {
        addressHooks.stream().filter(hook -> hook.getAddress().equals(address))
                .findFirst()
                .ifPresentOrElse(hook -> events.forEach(hook::addEvent), () -> {
                    var hook = new AddressHook(address, timestamp);
                    events.forEach(hook::addEvent);

                    addressHooks.add(hook);
                });
    }

    public void unregister(String address) {
        addressHooks.removeIf(hook -> hook.getAddress().equals(address));
    }

    public void unregister(TxnEvent event) {
        addressHooks.stream()
                .filter(hook -> hook.getEvents().stream().anyMatch(e -> e.getTxid().equals(event.getTxid())))
                .findFirst()
                .ifPresent(hook -> hook.getEvents().remove(event));
    }

    public AddressHook find(String address) {
        return addressHooks.stream().filter(hook -> hook.getAddress().equals(address))
                .findFirst()
                .orElse(null);
    }

    public Set<AddressHook> getAddressHooks() {
        return addressHooks;
    }

    @Override
    public void clean() {
        addressHooks.clear();
    }
}