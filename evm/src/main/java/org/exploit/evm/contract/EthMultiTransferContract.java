package org.exploit.evm.contract;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.exploit.evm.address.EvmWallet;
import org.exploit.evm.protocol.EthCall;
import org.exploit.evm.protocol.Transaction;
import org.exploit.finja.core.OutgoingTransaction;
import org.exploit.finja.core.SmartContractWallet;
import org.exploit.finja.core.contract.SolidityContract;
import org.exploit.finja.core.contract.transaction.ContractCall;
import org.exploit.finja.core.model.Receipt;
import org.web3j.abi.FunctionEncoder;
import org.web3j.abi.TypeReference;
import org.web3j.abi.datatypes.Address;
import org.web3j.abi.datatypes.DynamicArray;
import org.web3j.abi.datatypes.Function;
import org.web3j.abi.datatypes.Type;
import org.web3j.abi.datatypes.generated.Uint256;

import java.math.BigInteger;
import java.util.Collections;
import java.util.List;

@Data
@NoArgsConstructor
@AllArgsConstructor
@SuppressWarnings("rawtypes")
public class EthMultiTransferContract implements SolidityContract {
    public static final String SEND_ETHER = "send";
    public static final String SEND_TOKEN = "sendToken";

    private String contractAddress;

    @Override
    public OutgoingTransaction execute(SmartContractWallet wallet, String functionName, List<Type> args) {
        if (!(wallet instanceof EvmWallet evmWallet))
            throw new IllegalArgumentException("Wallet should be EvmWallet");

        if (functionName.equals(SEND_ETHER))
            return wallet.transactions().sign(send(evmWallet, args));

        if (functionName.equals(SEND_TOKEN))
            return wallet.transactions().sign(sendToken(evmWallet, args));

        throw new IllegalArgumentException("Unknown function: " + functionName);
    }

    @Override
    public ContractCall call(SmartContractWallet wallet, String functionName, List<Type> args) {
        return null;
    }

    public OutgoingTransaction execute(EvmWallet address, String functionName, List<Type> args) {
       if (functionName.equals(SEND_ETHER))
           return address.transactions().sign(send(address, args));

       if (functionName.equals(SEND_TOKEN))
           return address.transactions().sign(sendToken(address, args));

       throw new IllegalArgumentException("Unknown function: " + functionName);
    }

    public EthCall call(EvmWallet address, String functionName, List<Type> args) {
        return null;
    }

    private Transaction send(EvmWallet address, List<Type> args) {
        DynamicArray<Uint256> amounts = asArray(args.get(1));

        var totalAmount = amounts.getValue().stream()
                .map(Uint256::getValue)
                .reduce(BigInteger.ZERO, BigInteger::add);

        var function = new Function("send", args, Collections.emptyList());
        var encoded = FunctionEncoder.encode(function);

        return builder(address, contractAddress, encoded, totalAmount).build();
    }

    private Transaction sendToken(EvmWallet address, List<Type> args) {
        var tokenContract = (Address) args.get(0);
        DynamicArray<Uint256> amounts = asArray(args.get(2));

        var totalAmount = amounts.getValue().stream()
                .map(Uint256::getValue)
                .reduce(BigInteger.ZERO, BigInteger::add);

        var function = new Function("sendToken", args, Collections.emptyList());
        var encoded = FunctionEncoder.encode(function);

        var approveReceipt = approve(address, tokenContract.getValue(), totalAmount);
        var builder = builder(address, contractAddress, encoded, null);

        return builder.build();
    }

    private Transaction.TransactionBuilder builder(EvmWallet address, String to, String input, BigInteger value) {
        var builder = address.transactions().builderFor(address.publicAddress()).to(to);

        if (input != null) builder.input(input);
        if (value != null) builder.value(value);

        return builder;
    }

    private Receipt approve(EvmWallet address, String contract, BigInteger amount) {
        var function = new Function(
                "approve",
                List.of(new Address(contractAddress), new Uint256(amount)),
                List.of(new TypeReference<Uint256>() {})
        );

        var encoded = FunctionEncoder.encode(function);

        var builder = address.transactions().builderFor(address.publicAddress())
                .input(encoded)
                .to(contract);

        var transaction = address.transactions().sign(builder.build());
        return transaction.send();
    }

    @SuppressWarnings({"unchecked"})
    private static <T extends Type> DynamicArray<T> asArray(Type type) {
        if (type instanceof DynamicArray) {
            return (DynamicArray<T>) type;
        } else {
            throw new ClassCastException(type.getTypeAsString() + " cannot be cast to DynamicArray");
        }
    }
}
