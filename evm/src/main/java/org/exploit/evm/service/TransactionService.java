package org.exploit.evm.service;

import org.bouncycastle.util.encoders.Hex;
import org.exploit.evm.EvmProvider;
import org.exploit.evm.protocol.EthOutgoing;
import org.exploit.evm.protocol.Transaction;
import org.exploit.finja.core.OutgoingTransaction;
import org.exploit.finja.core.constant.AmountUnit;
import org.exploit.finja.core.constant.Flag;
import org.exploit.finja.core.contract.transaction.SmartTransaction;
import org.exploit.finja.core.contract.transaction.SmartTransactionService;
import org.exploit.finja.core.exception.NotEnoughBalanceException;
import org.exploit.finja.core.key.ECKeyManager;
import org.exploit.finja.core.model.Amount;
import org.exploit.finja.stereotype.Sensitive;
import org.web3j.abi.FunctionEncoder;
import org.web3j.abi.datatypes.Address;
import org.web3j.abi.datatypes.Function;
import org.web3j.abi.datatypes.generated.Uint256;

import java.math.BigInteger;
import java.util.List;

public class TransactionService implements Sensitive, SmartTransactionService {
    private final EvmProvider provider;
    private final ECKeyManager keyManager;

    public TransactionService(EvmProvider provider, ECKeyManager keyManager) {
        this.provider = provider;
        this.keyManager = keyManager;
    }

    public OutgoingTransaction sendTransaction(String from, String to, Amount amount, int flags) {
        var builder = builderFor(from).to(to);
        var value = amount.amountUnit() == AmountUnit.UNIT
                ? amount.value().toBigInteger()
                : provider.converter().toUnit(amount.value());

        return sign(applyGasAdjustment(builder, value, flags).build());
    }

    private Transaction.TransactionBuilder applyGasAdjustment(Transaction.TransactionBuilder builder, BigInteger value, int flags) {
        if ((flags & Flag.INCLUDE_FEE) != 0) {
            var estimatedGas = provider.client().estimateGas(builder.build().toCall());
            var gasPrice = builder.build().getGasPrice();

            var fee = estimatedGas.multiply(gasPrice);

            var adjustedValue = value.subtract(fee);

            if (adjustedValue.compareTo(BigInteger.ZERO) <= 0) {
                throw new NotEnoughBalanceException("Not enough funds to cover the fee with INCLUDE_FEE flag.");
            }

            return builder.value(adjustedValue).gasLimit(estimatedGas);
        } else {
            return builder.value(value);
        }
    }

    public OutgoingTransaction sendTransaction(String from, String to, String contractAddress, Amount amount) {
        var builder = applyTransferContract(builderFor(from), to, contractAddress, amount);
        return sign(builder.build());
    }

    public String sendTransaction(String signed) {
        return provider.client().sendTransaction(signed);
    }

    public Transaction.TransactionBuilder builderFor(String address) {
        var nonce = provider.client().getNonce(address);
        var gasPrice = provider.client().getAverageGasPrice();

        return Transaction.newBuilder().from(address)
                .chainId(provider.getChainId())
                .nonce(nonce)
                .gasPrice(gasPrice);
    }

    public Transaction.TransactionBuilder applyTransferContract(
            Transaction.TransactionBuilder builder, String to,
            String contractAddress, Amount amount
    ) {
        var unitAmount = (amount.amountUnit() == AmountUnit.UNIT) ? amount.value().toBigInteger()
                : provider.converter().toUnit(amount.value(), contractAddress);

        var address = new Address(to);

        var function = new Function("transfer", List.of(address, new Uint256(unitAmount)), List.of());
        var encoded = FunctionEncoder.encode(function);

        return builder.input(encoded).to(contractAddress);
    }

    public EthOutgoing sign(Transaction tx) {
        if (tx.getGasLimit() == null) {
            var estimatedGas = provider.client().estimateGas(tx.toCall());
            tx.setGasLimit(estimatedGas);
        }

        return outgoing(tx);
    }

    private EthOutgoing outgoing(Transaction tx) {
        var signedTx = "0x" + Hex.toHexString(tx.sign(keyManager));
        return new EthOutgoing(signedTx, tx, this);
    }

    @Override
    public void erase() {
        keyManager.erase();
    }

    @Override
    public OutgoingTransaction sign(SmartTransaction transaction) {
        if (!(transaction instanceof Transaction tx))
            throw new IllegalArgumentException("Unsupported EVM transaction type: " + transaction.getClass().getName());

        if (tx.getGasLimit() == null) {
            var estimatedGas = provider.client().estimateGas(tx.toCall());
            tx.setGasLimit(estimatedGas);
        }

        return outgoing(tx);
    }
}
