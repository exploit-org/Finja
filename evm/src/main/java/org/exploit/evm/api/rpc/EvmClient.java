package org.exploit.evm.api.rpc;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.node.NullNode;
import com.fasterxml.jackson.databind.node.TextNode;
import org.exploit.evm.constant.BlockParameter;
import org.exploit.evm.model.Block;
import org.exploit.evm.model.EthTransaction;
import org.exploit.evm.model.FullBlock;
import org.exploit.evm.model.SubscriptionConfig;
import org.exploit.evm.protocol.EthCall;
import org.exploit.evm.protocol.Transaction;
import org.exploit.evm.utils.MonoFunction;
import org.exploit.finja.core.exception.TransactionSendException;
import org.exploit.finja.core.model.JsonRpc;
import org.exploit.finja.core.model.WebData;
import org.exploit.finja.exception.TransactionNotFoundException;
import org.exploit.finja.utils.Jackson;
import org.web3j.abi.FunctionEncoder;
import org.web3j.abi.TypeReference;
import org.web3j.abi.datatypes.Address;
import org.web3j.abi.datatypes.Function;
import org.web3j.abi.datatypes.generated.Uint8;
import org.web3j.utils.Numeric;
import reactor.core.Disposable;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import reactor.core.publisher.Sinks;
import reactor.core.scheduler.Schedulers;
import reactor.netty.NettyOutbound;

import java.math.BigInteger;
import java.util.Collections;
import java.util.List;
import java.util.Optional;

public class EvmClient {
    private final WebData webData;
    private final JsonRpcApi api;

    public EvmClient(WebData webData) {
        this.webData = webData;
        this.api = webData.newApiClient(JsonRpcApi.class);
    }

    public String sendTransaction(String hex) {
        var rpc = JsonRpc.newBuilder()
                .method("eth_sendRawTransaction")
                .params(List.of(hex))
                .build();

        var node = api.sendJson(rpc);

        if (node.has("error")) {
            var message = Optional.ofNullable(node.get("error").get("message"))
                    .map(JsonNode::asText)
                    .orElse("Unknown error");

            throw new TransactionSendException(message);
        }
        return node.get("result").asText();
    }

    public FullBlock getFullBlockByHash(String hash) {
        var rpc = JsonRpc.newBuilder()
                .method("eth_getBlockByHash")
                .params(List.of(hash, true))
                .build();

        var node = api.sendJson(rpc);
        return Jackson.convert(node.get("result"), FullBlock.class);
    }

    public FullBlock getFullBlockByNumber(BigInteger number) {
        var rpc = JsonRpc.newBuilder()
                .method("eth_getBlockByNumber")
                .params(List.of(Numeric.encodeQuantity(number), true))
                .build();

        var node = api.sendJson(rpc);
        return Jackson.convert(node.get("result"), FullBlock.class);
    }

    public Block getBlockByNumber(BigInteger number) {
        var rpc = JsonRpc.newBuilder()
                .method("eth_getBlockByNumber")
                .params(List.of(Numeric.encodeQuantity(number), false))
                .build();

        var node = api.sendJson(rpc);
        return Jackson.convert(node.get("result"), Block.class);
    }

    public Block getBlockByHash(String hash) {
        var rpc = JsonRpc.newBuilder()
                .method("eth_getBlockByHash")
                .params(List.of(hash, false))
                .build();

        var node = api.sendJson(rpc);
        return Jackson.convert(node.get("result"), Block.class);
    }

    public BigInteger getNonce(String address) {
        var rpc = JsonRpc.newBuilder()
                .method("eth_getTransactionCount")
                .params(List.of(address, "pending"))
                .build();

        var node = api.sendJson(rpc);
        return Numeric.toBigInt(node.get("result").asText());
    }

    public BigInteger getAverageGasPrice() {
        var rpc = JsonRpc.newBuilder()
                .method("eth_gasPrice")
                .build();

        var node = api.sendJson(rpc);
        return Numeric.toBigInt(node.get("result").asText());
    }

    public EthTransaction getTransaction(String txid) {
        var rpc = JsonRpc.newBuilder()
                .method("eth_getTransactionByHash")
                .params(List.of(txid))
                .build();

        var node = api.sendJson(rpc);
        var result = node.get("result");

        if (result == null || result instanceof NullNode) {
            throw new TransactionNotFoundException(txid);
        }

        return Jackson.convert(result, EthTransaction.class);
    }

    public JsonNode getTransactionRaw(String txid) {
        var rpc = JsonRpc.newBuilder()
                .method("eth_getTransactionByHash")
                .params(List.of(txid))
                .build();

        return api.sendJson(rpc);
    }

    public JsonNode ethCall(EthCall transaction, BlockParameter blockParameter) {
        var rpc = JsonRpc.newBuilder()
                .method("eth_call")
                .params(List.of(transaction, blockParameter.value()))
                .build();

        return api.sendJson(rpc);
    }

    public BigInteger tokenDecimals(String contractAddress) {
        var function = new Function(
                "decimals",
                Collections.emptyList(),
                Collections.singletonList(new TypeReference<Uint8>() {})
        );

        var input = FunctionEncoder.encode(function);
        var contract = new Address(contractAddress);
        var call = Transaction.newBuilder()
                .to(contract.toString())
                .input(input)
                .build()
                .toCall();

        var node = ethCall(call, BlockParameter.LATEST);
        return Numeric.toBigInt(node.get("result").asText());
    }

    public BigInteger estimateGas(EthCall call) {
        var rpc = JsonRpc.newBuilder()
                .method("eth_estimateGas")
                .params(List.of(call))
                .build();

        var node = api.sendJson(rpc);
        return Numeric.toBigInt(node.get("result").asText());
    }

    public BigInteger currentBlockNumber() {
        var rpc = JsonRpc.newBuilder()
                .method("eth_blockNumber")
                .build();

        var node = api.sendJson(rpc);
        return Numeric.toBigInt(node.get("result").asText());
    }

    public BigInteger confirmations(String txid) {
        var tx = getTransaction(txid);
        var blockNumber = tx.blockNumber();

        if (blockNumber == null || blockNumber.isEmpty()) {
            return BigInteger.ZERO;
        }

        var current = currentBlockNumber();
        return current.subtract(Numeric.toBigInt(blockNumber));
    }

    public BigInteger confirmations(String txid, BigInteger current) {
        var tx = getTransaction(txid);
        var blockNumber = tx.blockNumber();

        if (blockNumber == null || blockNumber.isEmpty()) {
            return BigInteger.ZERO;
        }

        return current.subtract(Numeric.toBigInt(blockNumber));
    }

    public BigInteger getBalance(String address, BlockParameter blockParameter) {
        var rpc = JsonRpc.newBuilder()
                .method("eth_getBalance")
                .params(List.of(address, blockParameter.value()))
                .build();

        var node = api.sendJson(rpc);
        return Numeric.toBigInt(node.get("result").asText());
    }

    public Disposable subscribe(String method, List<Object> params, MonoFunction<JsonNode, Void> handler) {
        return subscribe(List.of(method, params), (node) -> {
            var paramsNode = node.get("params");
            if (paramsNode == null || paramsNode instanceof NullNode) {
                return Mono.empty();
            }

            var result = paramsNode.get("result");
            if (result == null || result instanceof NullNode) {
                return Mono.empty();
            }

            return handler.apply(result);
        });
    }

    public Disposable subscribeTransactions(SubscriptionConfig config, MonoFunction<EthTransaction, Void> handler) {
        Sinks.Many<String> txidSink = Sinks.many().unicast().onBackpressureBuffer();

        subscribeToNewTransactions(txidSink);

        return txidSink.asFlux()
                .buffer(config.getBuffer())
                .flatMap(list -> processTransactions(list, handler, txidSink), config.getThreads())
                .subscribe();
    }

    public Disposable subscribeBlockHeaders(MonoFunction<String, Void> handler) {
        return subscribe("newHeads", List.of(), (result) -> {
            var number = result.get("number");

            if (!(number instanceof TextNode text))
                return Mono.empty();

            return handler.apply(text.asText());
        });
    }

    private Disposable subscribe(List<Object> params, MonoFunction<JsonNode, Void> handler) {
        return new EtherHook(webData, this, params, handler).bind();
    }

    Mono<Void> sendSubscriptionRequest(NettyOutbound webSocketOutbound, List<Object> params) {
        var rpc = JsonRpc.newBuilder()
                .method("eth_subscribe")
                .params(params)
                .build()
                .asString();

        return webSocketOutbound.sendString(Mono.just(rpc)).then();
    }

    private void subscribeToNewTransactions(Sinks.Many<String> txidSink) {
        subscribe("newPendingTransactions", List.of(), (node) -> {
            if (!(node instanceof TextNode text))
                return Mono.empty();

            txidSink.tryEmitNext(text.asText());
            return Mono.empty();
        });
    }

    private Flux<Void> processTransactions(List<String> txids, MonoFunction<EthTransaction, Void> handler, Sinks.Many<String> txidSink) {
        return Flux.fromIterable(txids)
                .parallel()
                .runOn(Schedulers.parallel())
                .flatMap(txid -> Mono.fromCallable(() -> getTransaction(txid)).flatMap(handler)
                        .onErrorResume(TransactionNotFoundException.class, t -> {
                            txidSink.tryEmitNext(txid);
                            return Mono.empty();
                        }))
                .sequential();
    }
}