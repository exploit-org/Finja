package org.exploit.evm.protocol;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.exploit.crypto.Hash;
import org.exploit.crypto.signature.ECDSASignature;
import org.exploit.finja.core.contract.transaction.SmartTransaction;
import org.exploit.finja.core.key.ECKeyManager;
import org.web3j.rlp.RlpEncoder;
import org.web3j.rlp.RlpList;
import org.web3j.rlp.RlpString;
import org.web3j.rlp.RlpType;
import org.web3j.utils.Numeric;

import java.math.BigInteger;
import java.util.ArrayList;
import java.util.List;

@Data
@AllArgsConstructor
@NoArgsConstructor
@Builder(builderMethodName = "newBuilder")
public class Transaction implements SmartTransaction {
    private BigInteger nonce;
    private BigInteger gasPrice;
    private BigInteger gasLimit;

    private String from;

    @Builder.Default
    private String to = "";

    private BigInteger value;

    @Builder.Default
    private String input = "";

    @Builder.Default
    private BigInteger chainId = BigInteger.ONE;

    private ArrayList<RlpType> createRlp() {
        var target = to.isEmpty() ? RlpString.create(new byte[0])
                : RlpString.create(Numeric.hexStringToByteArray(to));

        var inputF = input.isEmpty() ? RlpString.create(new byte[0])
                : RlpString.create(Numeric.hexStringToByteArray(input));

        return new ArrayList<>(
                List.of(
                        RlpString.create(nonce),
                        RlpString.create(gasPrice),
                        RlpString.create(gasLimit),
                        target,
                        RlpString.create(value),
                        inputF
                ));
    }

    public byte[] sign(ECKeyManager keyManager) {
        var rlpList = createRlp();

        var rawBytes = RlpEncoder.encode(new RlpList(prepareForSigning(rlpList)));
        var hashedTransaction = Hash.keccak256(rawBytes);

        var signature = (ECDSASignature) keyManager.sign(hashedTransaction);

        var result = chainId.intValueExact() * 2 + 35 + signature.getRecId();
        var v = BigInteger.valueOf(result);

        var r = signature.getR();
        var s = signature.getS();

        rlpList.addAll(List.of(
                RlpString.create(v), RlpString.create(r),
                RlpString.create(s)
        ));

        return RlpEncoder.encode(new RlpList(rlpList));
    }

    private List<RlpType> prepareForSigning(List<RlpType> original) {
        var toSign = new ArrayList<>(List.copyOf(original));
        toSign.add(RlpString.create(chainId));
        toSign.add(RlpString.create(BigInteger.ZERO));
        toSign.add(RlpString.create(BigInteger.ZERO));

        return toSign;
    }

    public BigInteger fee() {
        return gasPrice.multiply(gasLimit);
    }

    public EthCall toCall() {
        var hexValue = value == null ? null : "0x" + value.toString(16);

        return new EthCall(from, to, hexValue, input);
    }

    public static class TransactionBuilder {}
}