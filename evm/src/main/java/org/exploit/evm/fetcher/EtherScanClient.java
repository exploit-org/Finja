package org.exploit.evm.fetcher;

import com.fasterxml.jackson.databind.JsonNode;
import org.exploit.evm.EvmProvider;
import org.exploit.evm.api.scan.EtherScanApi;
import org.exploit.evm.model.scan.EthScanTransaction;
import org.exploit.evm.model.scan.SingleResultResponse;
import org.exploit.evm.model.scan.TransactionListResponse;
import org.exploit.finja.core.EventClient;
import org.exploit.finja.core.EventFetcher;
import org.exploit.finja.core.model.WebData;
import org.exploit.finja.utils.Jackson;
import reactor.core.publisher.Mono;

import java.time.Duration;
import java.time.Instant;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

public class EtherScanClient implements EventClient<EvmProvider> {
    private final EtherScanApi api;

    public EtherScanClient(WebData webData) {
        this.api = webData.newApiClient(EtherScanApi.class);
    }

    @Override
    public EventFetcher createEventFetcher(EvmProvider provider) {
        return new EtherScanFetcher(provider, this);
    }

    public Mono<List<EthScanTransaction>> transactions(String address, long minTimestamp) {
        return fetchTransactionsRecursive(address, minTimestamp, 1, new ArrayList<>());
    }

    private Mono<List<EthScanTransaction>> fetchTransactionsRecursive(
            String address, long minTimestamp, int page,
            List<EthScanTransaction> gathered
    ) {
        return currentBlock()
                .map(block -> txParams(address, block, page))
                .flatMap(this::call)
                .map(node -> Jackson.convert(node, TransactionListResponse.class).result())
                .flatMap(transactions -> {
                    gathered.addAll(validTxs(transactions, minTimestamp));

                    if (hasOldTxs(transactions, minTimestamp) || transactions.isEmpty())
                        return Mono.just(gathered);

                    return Mono.delay(Duration.ofMillis(300L))
                            .then(fetchTransactionsRecursive(address, minTimestamp, page + 1, gathered));
                });
    }

    public Mono<Long> currentBlock() {
        var params = Map.of(
                "module", "block",
                "action", "getblocknobytime",
                "timestamp", String.valueOf(Instant.now().getEpochSecond()),
                "closest", "before"
        );

        return call(params).map(node -> Jackson.convert(node, SingleResultResponse.class))
                .map(response -> Long.parseLong(response.result()));
    }

    public Mono<JsonNode> call(Map<String, String> query) {
        return Mono.fromCallable(() -> api.call(query));
    }

    private List<EthScanTransaction> validTxs(List<EthScanTransaction> txs, long timestamp) {
        return txs.stream()
                .filter(tx -> Instant.ofEpochSecond(Long.parseLong(tx.timeStamp())).toEpochMilli() >= timestamp)
                .toList();
    }

    private boolean hasOldTxs(List<EthScanTransaction> txs, long timestamp) {
        return txs.stream()
                .anyMatch(tx -> Long.parseLong(tx.timeStamp()) < timestamp);
    }

    private Map<String, String> txParams(String address, long block, int page) {
        return Map.of(
                "module", "account",
                "action", "txlist",
                "address", address,
                "startblock", "0",
                "endblock", String.valueOf(block),
                "sort", "desc",
                "page", String.valueOf(page),
                "offset", String.valueOf(20)
        );
    }
}
