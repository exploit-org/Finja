package org.exploit.evm.fetcher;

import lombok.AllArgsConstructor;
import org.exploit.evm.EvmProvider;
import org.exploit.evm.model.scan.EthScanTransaction;
import org.exploit.finja.core.EventFetcher;
import org.exploit.finja.core.constant.Asset;
import org.exploit.finja.core.constant.TxType;
import org.exploit.finja.core.event.TxnEvent;
import org.exploit.finja.core.model.Value;
import org.exploit.finja.utils.Functions;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

import java.math.BigInteger;
import java.time.Instant;

@AllArgsConstructor
public class EtherScanFetcher implements EventFetcher {
    private final EvmProvider provider;
    private final EtherScanClient client;

    @Override
    public Flux<TxnEvent> events(String address, long startTimestamp) {
        return client.transactions(address, startTimestamp)
                .flatMapMany(Flux::fromIterable)
                .flatMap(transaction -> convert(address, transaction));
    }

    private Mono<TxnEvent> convert(String address, EthScanTransaction transaction) {
        var smartContract = transaction.contractAddress();

        if (smartContract == null || smartContract.isEmpty())
            return convertDefault(address, transaction);

        return convertSmartContract(address, transaction);
    }

    private Mono<TxnEvent> convertDefault(String address, EthScanTransaction transaction) {
        var type = typeOf(transaction, address);

        var amount = Long.parseLong(transaction.value());
        var confirmations = Integer.parseInt(transaction.confirmations());

        return valueOfDefault(amount)
                .map(value -> TxnEvent.builder()
                        .type(type)
                        .asset(Asset.EVM)
                        .txid(transaction.hash())
                        .address(address)
                        .value(value)
                        .confirmations(confirmations)
                        .timestamp(Instant.ofEpochSecond(Long.parseLong(transaction.timeStamp())).toEpochMilli())
                        .build());
    }

    private Mono<TxnEvent> convertSmartContract(String address, EthScanTransaction tx) {
        var type = typeOf(tx, address);
        var functionName = tx.functionName();

        if (!functionName.startsWith("transfer"))
            return Mono.empty();

        var contractAddress = tx.contractAddress();
        var data = Functions.decodeTransfer(tx.input());

        var amount = data.second();

        return valueOfSmartContract(amount, contractAddress)
                .map(value -> newEvent(type, tx, address, value, contractAddress));
    }

    private Mono<Value> valueOfDefault(long amount) {
        var unitAmount = BigInteger.valueOf(amount);
        var humanAmount = provider.converter().toHuman(unitAmount);

        return Mono.just(new Value(humanAmount, unitAmount));
    }

    private Mono<Value> valueOfSmartContract(BigInteger unitAmount, String contractAddress) {
        return Mono.fromCallable(() -> provider.converter().toHuman(unitAmount, contractAddress))
                .map(human -> new Value(human, unitAmount));
    }

    private TxType typeOf(EthScanTransaction tx, String address) {
        var from = tx.from();

        return from.equalsIgnoreCase(address) ? TxType.SEND : TxType.RECEIVE;
    }

    private TxnEvent newEvent(TxType type, EthScanTransaction tx, String address, Value value, String smartContract) {
        var txid = tx.hash();
        var confirmations = Integer.parseInt(tx.confirmations());

        return TxnEvent.builder()
                .asset(Asset.EVM)
                .txid(txid)
                .value(value)
                .type(type)
                .address(address)
                .confirmations(confirmations)
                .smartContract(smartContract)
                .timestamp(Instant.ofEpochSecond(Long.parseLong(tx.timeStamp())).toEpochMilli())
                .build();
    }
}
