package org.exploit.hdwallet;

import lombok.RequiredArgsConstructor;
import org.exploit.crypto.Hash;
import org.exploit.crypto.constant.SupportedCurve;
import org.exploit.crypto.key.ECPublicKey;
import org.exploit.gmp.BigInt;
import org.exploit.hdwallet.key.XKeyPair;
import org.exploit.hdwallet.key.XPrivateKey;
import org.exploit.hdwallet.utils.ChainUtil;
import org.exploit.hdwallet.utils.ChildIndex;
import org.exploit.hdwallet.utils.XKeyUtil;
import org.exploit.tss.curve.PointOps;

import java.util.Arrays;

@RequiredArgsConstructor
public final class HDKeyService {
    private final int maxDerivations;

    public XKeyPair<?> deriveChildKey(XKeyPair<?> parent, int childIndex, byte[] chainCode) {
        return deriveChildKey(parent, childIndex, 0, chainCode);
    }

    private XKeyPair<?> deriveChildKey(XKeyPair<?> parent, int childIndex, int iterations, byte[] chainCode) {
        var data = derivationData(parent, childIndex);
        var xPriv = parent.xPrivateKey();

        var chainHash = (xPriv == null)
                ? ChainUtil.hash(chainCode, data)
                : ChainUtil.hash(parent.xPrivateKey().chainCode(), data);

        var il = chainHash.il();

        if (parent.curve() == SupportedCurve.SECP256K1) {
            var privateKeyInt = (xPriv != null) ? parent.xPrivateKey().asECPrivateKey().toBigInt() : BigInt.ZERO;

            if (!privateKeyInt.equals(BigInt.ZERO) && !XKeyUtil.isValidKey(parent.curve(), il, privateKeyInt)) {
                validateIterations(iterations);
                return deriveChildKey(parent, childIndex + 1, iterations + 1, chainCode);
            }

            return createNewKeyPair(parent, childIndex, il, chainHash.chainCode(), xPriv == null ? chainCode : null);
        } else if (parent.curve() == SupportedCurve.ED25519) {
            return createNewKeyPair(parent, childIndex, il, chainHash.chainCode(), xPriv == null ? chainCode : null);
        } else {
            throw new UnsupportedOperationException("Unsupported curve: " + parent.curve());
        }
    }

    private static byte[] fingerprint(ECPublicKey<?> publicKey) {
        return Arrays.copyOfRange(Hash.ripeMd160(Hash.sha256(publicKey.compress())), 0, 4);
    }

    private void validateIterations(int iterations) {
        if (iterations >= maxDerivations)
            throw new IllegalStateException("Too many derivations. Possibly a bad seed.");
    }

    private static byte[] derivationData(XKeyPair<?> parent, int childIndex) {
        var hardened = ChildIndex.isHardened(childIndex);
        var privateKey = parent.xPrivateKey();

        if (hardened && privateKey == null)
            throw new IllegalArgumentException("Passed hardened index, but private key is null");

        return hardened
                ? privateKey.asECPrivateKey().prepareHardenedData(childIndex)
                : parent.xPublicKey().asECPublicKey().prepareNonHardenedData(childIndex);
    }

    private static <P extends PointOps<P>> XKeyPair<P> createNewKeyPair(XKeyPair<P> parent, int childIndex, byte[] il, byte[] newChainCode, byte[] fallbackChainCode) {
        var parentFingerprint = fingerprint(parent.xPublicKey().asECPublicKey());
        var depth = parent.xPublicKey().depth() + 1;

        XPrivateKey xPrivateKey = null;

        if (parent.xPrivateKey() != null) {
            if (parent.curve() == SupportedCurve.SECP256K1) {
                xPrivateKey = parent.newPrivateKey(childIndex, il, newChainCode, parentFingerprint, depth);
            } else if (parent.curve() == SupportedCurve.ED25519) {
                xPrivateKey = parent.newPrivateKey(childIndex, il, newChainCode, parentFingerprint, depth);
            }
        }

        var chainCode = newChainCode != null ? newChainCode : fallbackChainCode;
        var xPublicKey = parent.newPublicKey(xPrivateKey, il, chainCode, parentFingerprint, depth, childIndex);

        return parent.newKeyPair(xPrivateKey, xPublicKey);
    }
}