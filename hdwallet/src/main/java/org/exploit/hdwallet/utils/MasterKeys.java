package org.exploit.hdwallet.utils;

import org.exploit.crypto.Base58;
import org.exploit.crypto.Hash;
import org.exploit.crypto.constant.SupportedCurve;
import org.exploit.crypto.curve.Ed25519Provider;
import org.exploit.crypto.curve.Secp256k1Provider;
import org.exploit.crypto.key.ed25519.Ed25519PrivateKey;
import org.exploit.crypto.key.ed25519.Ed25519PublicKey;
import org.exploit.crypto.key.secp256k1.Secp256k1PrivateKey;
import org.exploit.crypto.key.secp256k1.Secp256k1PublicKey;
import org.exploit.hdwallet.key.XKeyPair;
import org.exploit.hdwallet.key.ed25519.XEd25519KeyPair;
import org.exploit.hdwallet.key.ed25519.XEd25519PrivateKey;
import org.exploit.hdwallet.key.ed25519.XEd25519PublicKey;
import org.exploit.hdwallet.key.secp256k1.XSecp256k1KeyPair;
import org.exploit.hdwallet.key.secp256k1.XSecp256k1PrivateKey;
import org.exploit.hdwallet.key.secp256k1.XSecp256k1PublicKey;
import org.exploit.hdwallet.model.Seed;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.math.BigInteger;
import java.nio.ByteBuffer;
import java.nio.charset.StandardCharsets;
import java.util.Arrays;

public final class MasterKeys {
    private MasterKeys() {}

    public static XKeyPair create(String hmacSeed, Seed seed, SupportedCurve curve) {
        var i = Hash.hmacSha512(hmacSeed.getBytes(StandardCharsets.UTF_8), seed.value());

        var provider = curve == SupportedCurve.SECP256K1 ? Secp256k1Provider.getInstance()
                : Ed25519Provider.getInstance();

        var masterKeyBytes = Arrays.copyOfRange(i, 0, 32);
        var masterChainCode = Arrays.copyOfRange(i, 32, 64);

        var masterKey = curve == SupportedCurve.SECP256K1
                ? Secp256k1PrivateKey.create(new BigInteger(1, masterKeyBytes))
                : Ed25519PrivateKey.create(masterKeyBytes);

        var publicKey = provider.getPublicKey(masterKey);

        return switch (curve) {
            case SECP256K1 -> {
                var xPrivateKey = new XSecp256k1PrivateKey(
                        (Secp256k1PrivateKey) masterKey,
                        masterChainCode,
                        EMPTY_PARENT_FINGERPRINT, 0, 0
                );

                var xPublicKey = new XSecp256k1PublicKey(
                        (Secp256k1PublicKey) publicKey,
                        masterChainCode,
                        EMPTY_PARENT_FINGERPRINT, 0, 0
                );

                yield new XSecp256k1KeyPair(xPrivateKey, xPublicKey);
            }

            case ED25519 -> {
                var xPrivateKey = new XEd25519PrivateKey(
                        (Ed25519PrivateKey) masterKey,
                        masterChainCode,
                        EMPTY_PARENT_FINGERPRINT, 0, 0
                );

                var xPublicKey = new XEd25519PublicKey(
                        (Ed25519PublicKey) publicKey,
                        masterChainCode,
                        EMPTY_PARENT_FINGERPRINT, 0, 0
                );

                yield new XEd25519KeyPair(xPrivateKey, xPublicKey);
            }
        };
    }

    public static XKeyPair create(Seed seed, SupportedCurve curve) {
        return create(curve.getDefaultSeed(), seed, curve);
    }

    public static String toBase58(
            byte[] version, int depth, byte[] parentFingerPrint,
            int index, byte[] chainCode, byte[] keyData
    ) {
        try (var stream = new ByteArrayOutputStream()) {
            stream.write(version);
            stream.write((byte) depth);
            stream.write(parentFingerPrint);

            var childNumberBytes = ByteBuffer.allocate(Integer.BYTES).putInt(index).array();
            stream.write(childNumberBytes);
            stream.write(chainCode);
            stream.write(keyData);

            var extendedKeyData = stream.toByteArray();
            var checksum = Hash.checksum(extendedKeyData);
            stream.write(checksum);

            return Base58.getInstance().encode(stream.toByteArray());
        } catch (IOException e) {
            throw new IllegalStateException(e);
        }
    }

    private static final byte[] EMPTY_PARENT_FINGERPRINT = new byte[4];
}
