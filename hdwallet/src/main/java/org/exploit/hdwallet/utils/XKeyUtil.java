package org.exploit.hdwallet.utils;

import lombok.Getter;
import org.exploit.crypto.Hash;
import org.exploit.crypto.constant.SupportedCurve;
import org.exploit.crypto.curve.Secp256k1Provider;
import org.exploit.crypto.key.ed25519.Ed25519PrivateKey;
import org.exploit.gmp.BigInt;
import org.jetbrains.annotations.NotNull;

import java.nio.ByteBuffer;
import java.util.Arrays;

public class XKeyUtil {
    private XKeyUtil() {}

    public static final byte[] XPUB_VERSION = {(byte) 0x04, (byte) 0x88, (byte) 0xB2, (byte) 0x1E};
    public static final byte[] XPRIV_VERSION = {(byte) 0x04, (byte) 0x88, (byte) 0xAD, (byte) 0xE4};

    public static boolean isValidKey(SupportedCurve curve, byte[] il, BigInt privateKeyInt) {
        return switch (curve) {
            case SECP256K1 -> {
                var n = Secp256k1Provider.CURVE.getCurveOrder();
                yield new BigInt(1, il).compareTo(n) < 0 && !privateKeyInt.equals(BigInt.ZERO);
            }
            case ED25519 -> {
                try {
                    Ed25519PrivateKey.create(Hash.sha512(il));
                    yield true;
                } catch (Exception e) {
                    yield false;
                }
            }
        };
    }

    private static ParsedData parseData(byte[] decoded) {
        return getParsedData(decoded);
    }

    @NotNull
    private static XKeyUtil.ParsedData getParsedData(byte[] decoded) {
        var buffer = ByteBuffer.wrap(decoded);

        byte[] version = new byte[4];
        buffer.get(version);

        int depth = buffer.get();

        byte[] parentFingerPrint = new byte[4];
        buffer.get(parentFingerPrint);

        int index = buffer.getInt();

        byte[] chainCode = new byte[32];
        buffer.get(chainCode);

        byte[] keyData = new byte[33];
        buffer.get(keyData);

        byte[] keyWithChecksum = new byte[decoded.length - 4];
        buffer.position(0);
        buffer.get(keyWithChecksum);
        byte[] checksum = new byte[4];
        buffer.get(checksum);

        if (!Arrays.equals(Hash.checksum(keyWithChecksum), checksum)) {
            throw new IllegalArgumentException("Invalid checksum");
        }

        return new ParsedData(version, depth, parentFingerPrint, index, chainCode, keyData);
    }

    @Getter
    public static class ParsedData {
        private final byte[] version;
        private final int depth;
        private final byte[] parentFingerPrint;
        private final int index;
        private final byte[] chainCode;
        private final byte[] keyData;

        ParsedData(byte[] version, int depth, byte[] parentFingerPrint, int index, byte[] chainCode, byte[] keyData) {
            this.version = version;
            this.depth = depth;
            this.parentFingerPrint = parentFingerPrint;
            this.index = index;
            this.chainCode = chainCode;
            this.keyData = keyData;
        }
    }
}