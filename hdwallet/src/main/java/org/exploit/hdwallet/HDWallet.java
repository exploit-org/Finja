package org.exploit.hdwallet;

import org.exploit.crypto.constant.SupportedCurve;
import org.exploit.finja.stereotype.Sensitive;
import org.exploit.hdwallet.key.XKeyPair;
import org.exploit.hdwallet.model.Seed;
import org.exploit.hdwallet.utils.LRUCache;
import org.exploit.hdwallet.utils.MasterKeys;

import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

public class HDWallet implements Sensitive {
    private final LRUCache<String, XKeyPair> derivedKeys = new LRUCache<>(128);
    private final Map<SupportedCurve, XKeyPair> masterKey = new ConcurrentHashMap<>();

    private final Seed seed;

    private final HDKeyService keyService;

    public HDWallet(Seed seed, int maxDerivations) {
        this.seed = seed;
        this.keyService = new HDKeyService(maxDerivations);
    }

    public HDWallet(Seed seed) {
        this(seed, 100);
    }

    public XKeyPair derive(SupportedCurve curve, String path, byte[] chainCode) {
        var masterKey = this.masterKey.computeIfAbsent(curve, (c) -> MasterKeys.create(seed, c));

        var parts = path.split("/");
        var currentKey = masterKey;

        for (var part : parts) {
            if (!part.equals("m")) {
                var index = getIndexFromPathPart(curve, part);
                currentKey = keyService.deriveChildKey(currentKey, index, chainCode);
            }
        }

        return currentKey;
    }

    public XKeyPair derive(SupportedCurve curve, String path) {
        return derive(curve, path, new byte[0]);
    }

    private int getIndexFromPathPart(SupportedCurve curve, String part) {
        var isHardened = part.endsWith("'") || curve == SupportedCurve.ED25519;
        var index = Integer.parseInt(part.replace("'", ""));

        if (isHardened)
            index |= 0x80000000;

        return index;
    }

    @Override
    public void erase() {
        masterKey.values().forEach(XKeyPair::erase);
        derivedKeys.values().forEach(XKeyPair::erase);
        derivedKeys.clear();
    }
}