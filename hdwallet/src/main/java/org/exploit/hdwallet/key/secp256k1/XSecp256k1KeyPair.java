package org.exploit.hdwallet.key.secp256k1;

import org.exploit.crypto.constant.SupportedCurve;
import org.exploit.crypto.curve.Secp256k1Provider;
import org.exploit.crypto.key.secp256k1.Secp256k1KeyPair;
import org.exploit.crypto.key.secp256k1.Secp256k1PrivateKey;
import org.exploit.crypto.key.secp256k1.Secp256k1PublicKey;
import org.exploit.hdwallet.key.XKeyPair;
import org.exploit.hdwallet.key.XPrivateKey;
import org.exploit.hdwallet.key.XPublicKey;

import java.math.BigInteger;

public class XSecp256k1KeyPair extends XKeyPair {
    public XSecp256k1KeyPair(XSecp256k1PrivateKey xPrivateKey, XSecp256k1PublicKey xPublicKey) {
        super(xPrivateKey, xPublicKey);
    }

    @Override
    public Secp256k1KeyPair asECKeyPair() {
        return new Secp256k1KeyPair(
            (Secp256k1PrivateKey) xPrivateKey().asECPrivateKey(),
            (Secp256k1PublicKey) xPublicKey().asECPublicKey()
        );
    }

    @Override
    public XPrivateKey newPrivateKey(int childIndex, byte[] il, byte[] newChainCode, byte[] parentFingerprint, int depth) {
        var privateKeyInt = xPrivateKey().asECPrivateKey().toBigInt()
                .add(new BigInteger(1, il))
                .mod(Secp256k1Provider.CURVE.getN());

        var newPrivateKey = Secp256k1PrivateKey.create(privateKeyInt);

        return new XSecp256k1PrivateKey(newPrivateKey, newChainCode, parentFingerprint, depth, childIndex);
    }

    @Override
    public XPublicKey newPublicKey(XPrivateKey privateKey, byte[] il, byte[] chainCode, byte[] parentFingerPrint, int depth, int index) {
        var publicKey = privateKey != null ? Secp256k1Provider.getInstance().getPublicKey(privateKey.asECPrivateKey()) :
                derivePublicKey(xPublicKey(), il);

        return new XSecp256k1PublicKey(publicKey, chainCode, parentFingerPrint, depth, index);
    }

    @Override
    public XKeyPair newKeyPair(XPrivateKey xPrivateKey, XPublicKey xPublicKey) {
        return new XSecp256k1KeyPair((XSecp256k1PrivateKey) xPrivateKey, (XSecp256k1PublicKey) xPublicKey);
    }

    @Override
    public SupportedCurve curve() {
        return SupportedCurve.SECP256K1;
    }

    private static Secp256k1PublicKey derivePublicKey(XPublicKey xPub, byte[] il) {
        var point = xPub.asECPublicKey().point();

        var newPoint = Secp256k1Provider.CURVE.getG()
                .multiply(new BigInteger(1, il))
                .add(point)
                .normalize();

        return Secp256k1PublicKey.create(newPoint.getEncoded(false));
    }
}