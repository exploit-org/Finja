package org.exploit.btc.utils;

import org.exploit.crypto.Bech32;
import org.exploit.crypto.utils.Require;

import java.util.ArrayList;

public final class Witness {
    private Witness() {
    }

    public static byte[] five2eight(byte[] input, int offset) {
        var buffer = 0L;

        var output = new ArrayList<Byte>();
        var count = 0;

        for (var i = offset; i < input.length; i++) {
            var b = input[i];
            buffer = (buffer << 5) | (b & 31);
            count += 5;

            while (count >= 8) {
                output.add((byte) ((buffer >> (count - 8)) & 0xff));
                count -= 8;
            }
        }

        if (count > 4)
            throw new IllegalArgumentException("Zero-padding of more than 4 bits");

        if ((buffer & ((1L << count) - 1L)) != 0L)
            throw new IllegalArgumentException("Non-zero padding in 8-to-5 conversion");

        var result = new byte[output.size()];

        for (int i = 0; i < output.size(); i++)
            result[i] = output.get(i);

        return result;
    }

    public static byte[] eight2five(byte[] input) {
        long buffer = 0L;
        ArrayList<Byte> output = new ArrayList<>();
        int count = 0;

        for (byte b : input) {
            buffer = (buffer << 8) | (b & 0xFFL);
            count += 8;
            while (count >= 5) {
                output.add((byte) ((buffer >> (count - 5)) & 0x1F));
                count -= 5;
            }
        }
        if (count > 0) {
            output.add((byte) ((buffer << (5 - count)) & 0x1F));
        }

        byte[] result = new byte[output.size()];
        for (int i = 0; i < output.size(); i++) {
            result[i] = output.get(i);
        }
        return result;
    }

    public static byte[] decode(String address) {
        var decoded = Bech32.decode(address);

        var data = decoded.data();
        var version = data[0];

        Require.isTrue(version >= 0 && version <= 16,
                () -> "Invalid segWit version: " + version
        );

        var bin = five2eight(data, 1);

        Require.isTrue(bin.length >= 2 && bin.length <= 40,
                () -> "Invalid segWit program length " + bin.length
        );

        if (version == 0) {
            Require.isTrue(decoded.encoding() == Bech32.Encoding.BECH32, () -> "Invalid Bech32 encoding");
            Require.isTrue(bin.length == 20 || bin.length == 32, () -> "Invalid witness program length");
        } else {
            Require.isTrue(decoded.encoding() == Bech32.Encoding.BECH32M, () -> "For versions 1..16 encoding is Bech32m");
        }

        return bin;
    }

    public static String encode(byte witnessVersion, String hrp, byte[] data) {
        var encoding = (witnessVersion == 0) ? Bech32.Encoding.BECH32 : Bech32.Encoding.BECH32M;
        var converted = eight2five(data);

        var bytes = new byte[converted.length + 1];
        bytes[0] = witnessVersion;
        System.arraycopy(converted, 0, bytes, 1, bytes.length - 1);

        return Bech32.encode(encoding, hrp, bytes);
    }
}
