package org.exploit.btc.generator;

import at.favre.lib.bytes.Bytes;
import org.exploit.crypto.Base58;
import org.exploit.crypto.Hash;
import org.exploit.crypto.curve.Secp256k1Provider;
import org.exploit.crypto.key.ECPublicKey;
import org.exploit.finja.core.constant.Asset;
import org.exploit.finja.core.model.CommonAddress;
import org.exploit.secp256k1.Secp256k1PointOps;

public class LegacyAddressGenerator implements BitcoinAddressGenerator {
    private final Asset asset;
    private final byte publicKeyNetworkByte;

    public LegacyAddressGenerator(Asset asset, byte publicKeyNetworkByte) {
        this.asset = asset;
        this.publicKeyNetworkByte = publicKeyNetworkByte;
    }

    @Override
    public CommonAddress generate() {
        var keyPair = Secp256k1Provider.getInstance().generateKeyPair();
        return generate(keyPair);
    }

    @Override
    public Asset asset() {
        return asset;
    }

    @Override
    public String encodePublicAddress(ECPublicKey<Secp256k1PointOps> publicKey) {
        var encodedPublicKey = publicKey.compress();

        var ripedBytes = Hash.hash160(encodedPublicKey);
        var extendedBytes = Bytes.from(publicKeyNetworkByte).append(ripedBytes)
                .array();

        var addressWithChecksum = Bytes.wrap(extendedBytes)
                .append(Hash.checksum(extendedBytes))
                .array();

        return Base58.getInstance().encode(addressWithChecksum);
    }
}
