package org.exploit.btc.protocol;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.exploit.btc.constant.TxFormat;
import org.exploit.btc.helper.TxUtils;
import org.exploit.btc.stereotype.BtcSerializable;
import org.exploit.btc.utils.BitcoinScripts;
import org.exploit.btc.utils.EndianAwareOutputStream;
import org.exploit.btc.utils.VarInt;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.UncheckedIOException;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.math.MathContext;
import java.math.RoundingMode;
import java.nio.ByteOrder;
import java.util.ArrayList;
import java.util.List;

import static org.exploit.btc.constant.Flag.SERIALIZE_NO_SIG_SCRIPT;
import static org.exploit.btc.constant.Flag.SERIALIZE_NO_WITNESS;

@Data
@AllArgsConstructor
@NoArgsConstructor
public final class Transaction implements BtcSerializable {
    private int version = 2;
    private List<TxIn> inputs = new ArrayList<>();
    private List<TxOut> outputs = new ArrayList<>();
    private long lockTime = 0;

    private TxFormat format;

    private long fee = 0L;

    public void addInput(TxIn input) {
        inputs.add(input);
    }

    public void addOutput(TxOut output) {
        outputs.add(output);
    }

    public BigInteger estimateFee(BigDecimal satPerByte) {
        var bitcoinScript = format == TxFormat.SEGWIT ? BitcoinScripts.P2WPKH
                : format == TxFormat.TAPROOT ? BitcoinScripts.P2TR
                : BitcoinScripts.P2PKH;

        var vSize = TxUtils.estimateSize(bitcoinScript, inputs.size(), outputs.size() + 1);

        return satPerByte.multiply(BigDecimal.valueOf(vSize), new MathContext(8, RoundingMode.CEILING))
                .toBigInteger();
    }

    public Transaction updateSigScript(int index, Script sigScript) {
        var txCopy = copy();
        txCopy.inputs.get(index).setSignatureScript(sigScript);

        return txCopy;
    }

    public boolean hasWitness() {
        return inputs.stream().anyMatch(TxIn::hasWitness);
    }

    @Override
    public byte[] serialize(int flags) {
        try (var out = new EndianAwareOutputStream(ByteOrder.LITTLE_ENDIAN)) {
            out.writeInt(version);

            if (hasWitness() && (flags & SERIALIZE_NO_WITNESS) != SERIALIZE_NO_WITNESS) {
                out.write(0x00);
                out.write(0x01);

                out.write(serializeInputs(flags));
                out.write(serializeOutputs(flags));

                var witness = inputs.stream()
                        .map(TxIn::getScriptWitness)
                        .map(w -> w.serialize(flags))
                        .toList();

                for (var w : witness)
                    out.write(w);

                out.writeInt((int) lockTime);
            } else {
                out.write(serializeInputs(flags));
                out.write(serializeOutputs(flags));
                out.writeInt((int) lockTime);
            }

            return out.toByteArray();
        } catch (IOException e) {
            throw new IllegalStateException(e);
        }
    }

    public int estimateSize() {
        var baseTransactionSize = serialize(SERIALIZE_NO_WITNESS | SERIALIZE_NO_SIG_SCRIPT).length;
        var multiplier = format == TxFormat.SEGWIT ? P2WPKH_ESTIMATE_SIG_LENGTH
                : format == TxFormat.TAPROOT ? TAPROOT_ESTIMATE_SIG_LENGTH
                : P2PKH_ESTIMATE_SIG_LENGTH;

        return baseTransactionSize + inputs.size() * multiplier;
    }

    public Transaction copy() {
        return new Transaction(version, inputs, outputs, lockTime, format, fee);
    }

    public Transaction copy(List<TxIn> inputs) {
        return new Transaction(version, inputs, outputs, lockTime, format, fee);
    }

    public Transaction copy(List<TxIn> inputs, List<TxOut> outputs) {
        return new Transaction(version, inputs, outputs, lockTime, format, fee);
    }

    private byte[] serializeOutputs(int flags) {
        try (var stream = new ByteArrayOutputStream()) {
            stream.write(new VarInt(outputs.size()).encode(ByteOrder.LITTLE_ENDIAN));

            for (TxOut output : outputs)
                stream.write(output.serialize(flags));

            return stream.toByteArray();
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
    }

    private byte[] serializeInputs(int flags) {
        try (var out = new ByteArrayOutputStream()) {
            out.write(new VarInt(inputs.size()).encode(ByteOrder.LITTLE_ENDIAN));

            for (var txin : inputs)
                out.write(txin.serialize(flags));

            return out.toByteArray();
        } catch (IOException e) {
            throw new IllegalStateException(e);
        }
    }

    private static final int P2WPKH_ESTIMATE_SIG_LENGTH = 71;
    private static final int P2PKH_ESTIMATE_SIG_LENGTH = 108;
    private static final int TAPROOT_ESTIMATE_SIG_LENGTH = 65;
}