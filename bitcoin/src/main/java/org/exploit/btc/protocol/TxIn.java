package org.exploit.btc.protocol;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.Setter;
import org.exploit.btc.constant.Sequence;
import org.exploit.btc.stereotype.BtcSerializable;

import java.nio.ByteBuffer;
import java.nio.ByteOrder;

import static org.exploit.btc.constant.Flag.SERIALIZE_NO_SIG_SCRIPT;

@Data
@AllArgsConstructor
@NoArgsConstructor
public final class TxIn implements BtcSerializable {
    private OutPoint outPoint;
    private long amount = 0L;
    private Script signatureScript = Script.create();
    private UTXO relatedUTXO;
    private long sequence = Sequence.EMPTY;
    @Setter
    private ScriptWitness scriptWitness = new ScriptWitness();

    @Override
    public byte[] serialize(int flags) {
        var outPointBytes = outPoint.serialize(flags);
        var scriptBytes = ((flags & SERIALIZE_NO_SIG_SCRIPT) == SERIALIZE_NO_SIG_SCRIPT) ? new byte[0]
                : signatureScript.serialize(flags);

        var buffer = ByteBuffer.allocate(outPointBytes.length + scriptBytes.length + Integer.BYTES);
        buffer.order(ByteOrder.LITTLE_ENDIAN)
                .put(outPointBytes)
                .put(scriptBytes)
                .putInt((int) sequence);

        return buffer.array();
    }

    public boolean hasWitness() {
        return scriptWitness != null && !scriptWitness.isEmpty();
    }

    public TxIn copy(Script signatureScript) {
        return new TxIn(outPoint, amount, signatureScript, relatedUTXO, sequence, scriptWitness);
    }

    public TxIn copy() {
        return new TxIn(outPoint, amount, signatureScript, relatedUTXO, sequence, scriptWitness);
    }
}