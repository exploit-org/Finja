package org.exploit.btc.protocol;

import lombok.Getter;
import org.bouncycastle.util.encoders.Hex;
import org.exploit.btc.constant.OpCode;
import org.exploit.btc.stereotype.BtcSerializable;
import org.exploit.btc.utils.Serializer;
import org.exploit.btc.utils.VarInt;
import org.exploit.crypto.utils.Require;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.nio.ByteOrder;
import java.util.ArrayList;
import java.util.List;
import java.util.StringJoiner;

import static org.exploit.btc.constant.OpCode.*;

@Getter
public final class Script implements BtcSerializable {
    private final List<Object> commands;

    public Script(List<Object> commands) {
        this.commands = commands;
    }

    public Script() {
        this(new ArrayList<>());
    }

    public Script op(OpCode opCode) {
        commands.add(opCode);
        return this;
    }

    public Script push(byte[] data) {
        commands.add(data);
        return this;
    }

    @Override
    public byte[] serialize(int flags) {
        try (var out = new ByteArrayOutputStream()) {
            var bytes = Serializer.serialize(this);
            var length = new VarInt(bytes.length).encode(ByteOrder.LITTLE_ENDIAN);

            out.write(length);
            out.write(bytes);

            return out.toByteArray();
        } catch (IOException e) {
            throw new IllegalStateException(e);
        }
    }

    public static Script parseHex(String hex) {
        var bytes = Hex.decode(hex);

        var commands = new ArrayList<>();

        var i = 0;

        while (i < bytes.length) {
            var value = bytes[i++] & 0xff;
            var opCode = OpCode.fromValue(value);

            if (opCode != null) {
                commands.add(opCode);
            } else {
                int length;

                if (value < 0x4c) {
                    length = value;
                } else if (value == 0x4c) {
                    length = bytes[i++] & 0xff;
                } else if (value == 0x4d) {
                    length = (bytes[i++] & 0xff) | ((bytes[i++] & 0xff) << 8);
                } else {
                    length = (bytes[i++] & 0xff) | ((bytes[i++] & 0xff) << 8) |
                            ((bytes[i++] & 0xff) << 16) | ((bytes[i++] & 0xff) << 24);
                }

                var data = new byte[length];
                System.arraycopy(bytes, i, data, 0, length);
                i += length;

                commands.add(data);
            }
        }

        return new Script(commands);
    }

    @Override
    public String toString() {
        var joiner = new StringJoiner(" ");

        for (var cmd : commands) {
            if (cmd instanceof OpCode op)
                joiner.add(op.name());
            else if (cmd instanceof byte[] bytes)
                joiner.add(Hex.toHexString(bytes));
            else
                joiner.add(cmd.toString());
        }

        return joiner.toString();
    }

    public static Script create() {
        return new Script();
    }

    public static Script pay2pkh(byte[] pubKeyHash) {
        Require.isTrue(pubKeyHash.length == 20, () -> "Public key hash should be 20 bytes length");

        return Script.create()
                .op(OP_DUP)
                .op(OP_HASH160)
                .push(pubKeyHash)
                .op(OP_EQUALVERIFY)
                .op(OP_CHECKSIG);
    }
}