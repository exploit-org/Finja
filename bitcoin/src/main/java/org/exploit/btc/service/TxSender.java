package org.exploit.btc.service;

import org.bouncycastle.util.encoders.Hex;
import org.exploit.btc.BitcoinProtocolProvider;
import org.exploit.btc.constant.SigHash;
import org.exploit.btc.constant.TxFormat;
import org.exploit.btc.helper.TransactionCreator;
import org.exploit.btc.helper.TxSigner;
import org.exploit.btc.model.SigData;
import org.exploit.btc.model.SignatureData;
import org.exploit.btc.protocol.BitcoinOutgoing;
import org.exploit.btc.protocol.LinkedUTXO;
import org.exploit.btc.protocol.Transaction;
import org.exploit.finja.core.OutgoingTransaction;
import org.exploit.finja.core.exception.NotEnoughBalanceException;
import org.exploit.finja.core.model.Receipt;
import org.exploit.finja.core.model.Recipient;

import java.math.BigInteger;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

public class TxSender {
    private final BitcoinProtocolProvider provider;
    private final TransactionCreator creator;

    public TxSender(BitcoinProtocolProvider provider, TransactionCreator creator) {
        this.provider = provider;
        this.creator = creator;
    }

    public OutgoingTransaction createMassTransaction(
            String changeAddress,
            List<SignatureData> senders,
            List<Recipient> recipients,
            int flags, int sigHash
    ) {
        if (senders.isEmpty()) {
            throw new IllegalArgumentException("No fromAddresses provided");
        }

        var keysByAddress = senders.stream().collect(
                Collectors.toMap(SignatureData::getPublicAddress, s -> s)
        );

        var firstKey = keysByAddress.values().iterator().next();
        var sigVersion = deriveSigVersion(firstKey);
        var sigData = SigData.of(sigHash, sigVersion);
        var format = deriveTxFormat(firstKey);

        List<LinkedUTXO> allUtxos = new ArrayList<>();
        for (var sender : senders) {
            allUtxos.addAll(provider.explorer().utxos(sender.getPublicAddress()).stream()
                    .map(utxo -> new LinkedUTXO(utxo, sender.getPublicAddress())).toList());
        }

        allUtxos.sort((a, b) -> Long.compare(b.amount(), a.amount()));

        var totalNeeded = recipients.stream()
                .map(Recipient::getAmount)
                .map(amount -> amount.asUnit(provider))
                .reduce(BigInteger.ZERO, BigInteger::add);

        var accumulated = BigInteger.ZERO;

        List<LinkedUTXO> selectedUtxos = new ArrayList<>();

        for (var utxo : allUtxos) {
            selectedUtxos.add(utxo);
            accumulated = accumulated.add(BigInteger.valueOf(utxo.amount()));

            if (accumulated.compareTo(totalNeeded) >= 0) {
                break;
            }
        }

        if (accumulated.compareTo(totalNeeded) < 0)
            throw new NotEnoughBalanceException("Not enough balance to cover mass transaction");

        var tx = creator.createTransaction(provider.asset(), format, changeAddress, selectedUtxos, recipients, flags);
        var signed = TxSigner.signMultiple(keysByAddress, tx, selectedUtxos, sigData);

        return new BitcoinOutgoing(signed, this);
    }

    public OutgoingTransaction createTransaction(SignatureData keyData, String from, List<Recipient> recipients, int flags, int sigHash) {
        var sigVersion = deriveSigVersion(keyData);

        var sigData = SigData.of(sigHash, sigVersion);
        var format = deriveTxFormat(keyData);

        var utxos = provider.explorer().utxos(from);
        var tx = creator.createTransaction(provider.asset(), format, from, utxos, recipients, flags);
        var signed = TxSigner.sign(keyData, tx, utxos, sigData);

        return new BitcoinOutgoing(signed, this);
    }

    public Receipt sendTransaction(Transaction transaction) {
        var serializedTransaction = transaction.serialize(0);
        var hex = Hex.toHexString(serializedTransaction);

        var txid =  provider.explorer().push(hex);

        return new Receipt(txid, transaction.getFee());
    }

    private int deriveSigVersion(SignatureData keyData) {
        return keyData.getScript().isSegWit() ? SigHash.SigVersion.SIGVERSION_WITNESS_V0
                : keyData.getScript().isTaproot() ? SigHash.SigVersion.SIGVERSION_TAPROOT
                : SigHash.SigVersion.SIGVERSION_BASE;
    }

    private TxFormat deriveTxFormat(SignatureData keyData) {
        return keyData.getScript().isSegWit() ? TxFormat.SEGWIT
                : keyData.getScript().isTaproot() ? TxFormat.TAPROOT
                : TxFormat.LEGACY;
    }
}