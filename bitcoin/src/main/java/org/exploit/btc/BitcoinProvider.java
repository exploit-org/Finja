package org.exploit.btc;

import org.exploit.btc.address.BitcoinWallet;
import org.exploit.btc.constant.AddressType;
import org.exploit.btc.constant.FeePolicy;
import org.exploit.btc.explorer.BitcoinExplorer;
import org.exploit.btc.fee.BitcoinFeeProvider;
import org.exploit.btc.generator.BitcoinAddressGenerator;
import org.exploit.btc.generator.LegacyAddressGenerator;
import org.exploit.btc.generator.SegWitAddressGenerator;
import org.exploit.btc.generator.TaprootAddressGenerator;
import org.exploit.btc.model.BitcoinMeta;
import org.exploit.btc.protocol.script.BitcoinScript;
import org.exploit.btc.utils.BitcoinScripts;
import org.exploit.crypto.Base58;
import org.exploit.finja.core.ValueConverter;
import org.exploit.finja.core.constant.Asset;
import org.exploit.finja.core.constant.NetworkType;
import org.exploit.finja.core.converter.MathConstantConverter;
import org.exploit.finja.core.key.ECKeyManager;
import org.exploit.finja.listener.ListenerProvider;

public class BitcoinProvider implements BitcoinProtocolProvider {
    private final BitcoinMeta meta;
    private final BitcoinExplorer explorer;
    private final ListenerProvider<BitcoinProtocolProvider> listenerProvider;
    private final BitcoinFeeProvider feeProvider;

    private BitcoinProvider(
        BitcoinMeta meta, BitcoinExplorer explorer,
        ListenerProvider<BitcoinProtocolProvider> listenerProvider,
        BitcoinFeeProvider feeProvider
    ) {
        this.meta = meta;
        this.explorer = explorer;
        this.listenerProvider = listenerProvider;
        this.feeProvider = feeProvider;
    }

    @Override
    public Asset asset() {
        return Asset.BTC;
    }

    @Override
    public BitcoinWallet createWallet(String publicAddress, ECKeyManager keyManager) {
        return new BitcoinWallet(this, publicAddress, keyManager);
    }

    @Override
    public BitcoinAddressGenerator generator(NetworkType network, AddressType type) {
        return switch (type) {
            case LEGACY -> network.isTest() ? new LegacyAddressGenerator(asset(), (byte) 0x6f)
                    : new LegacyAddressGenerator(asset(), (byte) 0x00);

            case SEGWIT -> network.isTest() ? new SegWitAddressGenerator(asset(), "tb")
                    : new SegWitAddressGenerator(asset(), "bc");

            case TAPROOT -> network.isTest() ? new TaprootAddressGenerator(asset(), "tb")
                    : new TaprootAddressGenerator(asset(), "bc");

            case CASH_ADDR -> throw new IllegalArgumentException("Bitcoin does not support CashAddr");
        };
    }

    @Override
    public ValueConverter converter() {
        return new MathConstantConverter(8);
    }

    @Override
    public BitcoinExplorer explorer() {
        return explorer;
    }

    @Override
    public BitcoinMeta meta() {
        return meta;
    }

    @Override
    public ListenerProvider<BitcoinProtocolProvider> listenerProvider() {
        return listenerProvider;
    }

    @Override
    public BitcoinFeeProvider feeProvider() {
        return feeProvider;
    }

    @Override
    public BitcoinScript getScript(String address) {
        if (address.startsWith("bc1") || address.startsWith("tb1"))
            return BitcoinScripts.resolveWitness(address);

        if (!Base58.getInstance().isValid(address))
            throw new IllegalArgumentException("Invalid address: " + address);

        var decoded = Base58.getInstance().decode(address);
        var prefix = decoded[0];

        if (prefix == 0x00 || prefix == 0x6F) {
            return BitcoinScripts.P2PKH;
        } else if (prefix == 0x05 || prefix == (byte) 0xC4) {
            return BitcoinScripts.P2SH;
        } else {
            throw new IllegalArgumentException("Unknown address type: " + address);
        }
    }

    public static Builder newBuilder() {
        return new Builder();
    }

    public static class Builder {
        private BitcoinMeta meta = new BitcoinMeta(NetworkType.MAIN, AddressType.SEGWIT, FeePolicy.NORMAL);

        private BitcoinExplorer explorer;
        private ListenerProvider<BitcoinProtocolProvider> listenerProvider;
        private BitcoinFeeProvider feeProvider;

        public Builder meta(BitcoinMeta meta) {
            this.meta = meta;
            return this;
        }

        public Builder explorer(BitcoinExplorer explorer) {
            this.explorer = explorer;
            return this;
        }

        public Builder listenerProvider(ListenerProvider<BitcoinProtocolProvider> listenerProvider) {
            this.listenerProvider = listenerProvider;
            return this;
        }

        public Builder feeProvider(BitcoinFeeProvider feeProvider) {
            this.feeProvider = feeProvider;
            return this;
        }

        public BitcoinProvider build() {
            return new BitcoinProvider(meta, explorer, listenerProvider, feeProvider);
        }
    }
}