package org.exploit.btc.helper;

import org.bouncycastle.util.encoders.Hex;
import org.exploit.btc.constant.OpCode;
import org.exploit.btc.constant.SigHash;
import org.exploit.btc.protocol.Script;
import org.exploit.btc.protocol.Transaction;
import org.exploit.btc.protocol.TxIn;
import org.exploit.btc.protocol.TxOut;
import org.exploit.btc.utils.EndianAwareOutputStream;
import org.exploit.crypto.Hash;

import java.io.IOException;
import java.io.UncheckedIOException;
import java.math.BigInteger;
import java.nio.ByteOrder;
import java.util.ArrayList;
import java.util.List;

import static org.exploit.btc.constant.SigHash.SIGHASH_NONE;
import static org.exploit.btc.constant.SigHash.SIGHASH_SINGLE;
import static org.exploit.btc.helper.TxUtils.removeAllSignatureScripts;
import static org.exploit.btc.helper.TxUtils.resetSequence;

public class TxSignatureHelper {
    private TxSignatureHelper() {
    }

    public static byte[] hashForSigning(Transaction tx, int inputIndex, Script prevOutputScript, int sigHash, long amount, int sigVersion) {
        if (sigVersion == SigHash.SigVersion.SIGVERSION_WITNESS_V0)
            return hashForSegWit(tx, inputIndex, prevOutputScript, sigHash, amount);

        if (sigVersion == SigHash.SigVersion.SIGVERSION_TAPROOT)
            return hashForTaproot(tx, inputIndex, sigHash, sigVersion);

        return defaultHashForSigning(tx, inputIndex, prevOutputScript, sigHash);
    }

    private static byte[] hashForTaproot(Transaction tx, int inputIndex, int sigHash, int sigVersion) {
        var inputs = tx.getInputs();

        try (var out = new EndianAwareOutputStream(ByteOrder.LITTLE_ENDIAN)) {
            out.write(0);

            if (sigHash > 0x03 && !(sigHash >= 0x81 && sigHash <= 0x83))
                throw new IllegalArgumentException("Invalid sighash type");

            out.write((byte) sigHash);
            out.writeInt(tx.getVersion());
            out.writeInt((int) tx.getLockTime());

            int inputType = sigHash & SigHash.SIGHASH_INPUT_MASK;

            if (inputType != SigHash.SIGHASH_ANYONECANPAY) {
                out.write(Hash.sha256(prevOuts(tx, sigHash)));
                out.write(Hash.sha256(amounts(tx)));
                out.write(Hash.sha256(pubScripts(tx)));
                out.write(Hash.sha256(sequences(tx, sigHash)));
            }

            var outputType = (sigHash == SigHash.SIGHASH_DEFAULT) ? SigHash.SIGHASH_ALL
                    : (sigHash & SigHash.SIGHASH_OUTPUT_MASK);

            if (outputType == SigHash.SIGHASH_ALL) {
                out.write(Hash.sha256(outputs(tx, sigHash, inputIndex)));
            }

            out.write(0); // spend type

            if (inputType == SigHash.SIGHASH_ANYONECANPAY) {
                out.write(inputs.get(inputIndex).getOutPoint().serialize(0));
                out.write(inputs.get(inputIndex).serialize(0));
                out.writeInt((int) inputs.get(inputIndex).getSequence());
            } else {
                out.writeInt(inputIndex);
            }

            if (outputType == SigHash.SIGHASH_SINGLE)
                out.write(Hash.sha256(inputs.get(inputIndex).serialize(0)));

            byte[] preimage = out.toByteArray();
            return Hash.taggedHash(preimage, "TapSighash");
        } catch (IOException e) {
            throw new IllegalStateException(e);
        }
    }

    private static byte[] defaultHashForSigning(Transaction tx, int inputIndex, Script prevOutputScript, int sigHash) {
        if (sigHash == SigHash.SIGHASH_SINGLE && inputIndex >= tx.getInputs().size())
            return ONE;

        var preparedTx = prepareForSigning(tx, inputIndex, prevOutputScript, sigHash);

        try (var out = new EndianAwareOutputStream(ByteOrder.LITTLE_ENDIAN)) {
            out.write(preparedTx.serialize(0));
            out.writeInt(sigHash);

            return Hash.doubleSha256(out.toByteArray());
        } catch (IOException e) {
            throw new IllegalStateException(e);
        }
    }

    private static Transaction prepareForSigning(Transaction tx, int inputIndex, Script prevOutputScript, int sigHash) {
        var filteredScript = new Script(prevOutputScript.getCommands().stream()
                .filter(o -> !o.equals(OpCode.OP_CODESEPARATOR))
                .toList());

        var sigUpdatedTx = removeAllSignatureScripts(tx)
                .updateSigScript(inputIndex, filteredScript);

        var preparedTx = switch (sigHash) {
            case SIGHASH_NONE -> {
                var inputs = resetSequence(sigUpdatedTx.getInputs(), inputIndex);
                yield sigUpdatedTx.copy(inputs, new ArrayList<>());
            }

            case SIGHASH_SINGLE -> {
                var inputs = resetSequence(sigUpdatedTx.getInputs(), inputIndex);
                var outputs = new ArrayList<TxOut>();

                for (int i = 0; i <= inputIndex; i++)
                    outputs.add(i == inputIndex ? sigUpdatedTx.getOutputs().get(i)
                            : new TxOut(BigInteger.valueOf(-1L), new Script()));

                yield sigUpdatedTx.copy(inputs, outputs);
            }

            default -> sigUpdatedTx;
        };

        return sigHash == SigHash.SIGHASH_ANYONECANPAY ? preparedTx.copy(List.of(preparedTx.getInputs().get(inputIndex))) : preparedTx;
    }

    private static byte[] hashForSegWit(Transaction tx, int inputIndex, Script prevOutputScript, int sigHash, long amount) {
        var hashPrevOut = Hash.doubleSha256(prevOuts(tx, sigHash));
        var hashSequence = Hash.doubleSha256(sequences(tx, sigHash));
        var hashOutputs = Hash.doubleSha256(outputs(tx, sigHash, inputIndex));

        try (var out = new EndianAwareOutputStream(ByteOrder.LITTLE_ENDIAN)) {
            out.writeInt(tx.getVersion());
            out.write(hashPrevOut);
            out.write(hashSequence);

            var input = tx.getInputs().get(inputIndex);

            out.write(input.getOutPoint().serialize(0));
            out.write(prevOutputScript.serialize(0));

            out.writeLong(amount);

            out.writeInt((int) input.getSequence());
            out.write(hashOutputs);
            out.writeInt((int) tx.getLockTime());
            out.writeInt(sigHash);

            return Hash.doubleSha256(out.toByteArray());
        } catch (IOException e) {
            throw new IllegalStateException(e);
        }
    }

    private static byte[] prevOuts(Transaction tx, int sigHash) {
        if (sigHash == SigHash.SIGHASH_ANYONECANPAY)
            return new byte[32];

        var bytes = tx.getInputs().stream()
                .map(TxIn::getOutPoint)
                .map(out -> out.serialize(0))
                .toList();

        try (var out = new EndianAwareOutputStream(ByteOrder.LITTLE_ENDIAN)) {
            for (var b : bytes)
                out.write(b);

            return out.toByteArray();
        } catch (IOException e) {
            throw new IllegalStateException(e);
        }
    }

    private static byte[] sequences(Transaction tx, int sigHash) {
        if (sigHash == SigHash.SIGHASH_ANYONECANPAY || sigHash == SigHash.SIGHASH_SINGLE || sigHash == SIGHASH_NONE)
            return new byte[32];

        try (var out = new EndianAwareOutputStream(ByteOrder.LITTLE_ENDIAN)) {
            for (var input : tx.getInputs())
                out.writeInt((int) input.getSequence());

            return out.toByteArray();
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
    }

    private static byte[] outputs(Transaction tx, int sigHash, int inputIndex) {
        if (sigHash != SigHash.SIGHASH_SINGLE && sigHash != SIGHASH_NONE) {
            try (var out = new EndianAwareOutputStream(ByteOrder.LITTLE_ENDIAN)) {
                for (var output : tx.getOutputs())
                    out.write(output.serialize(0));

                return out.toByteArray();
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
        } else if (sigHash == SigHash.SIGHASH_SINGLE && inputIndex < tx.getOutputs().size())
            return tx.getOutputs().get(inputIndex).serialize(0);
        else
            return new byte[32];
    }

    private static byte[] amounts(Transaction tx) {
        try (var out = new EndianAwareOutputStream(ByteOrder.LITTLE_ENDIAN)) {
            for (var in : tx.getInputs()) {
                out.writeLong(in.getAmount());
            }

            return out.toByteArray();
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
    }

    private static byte[] pubScripts(Transaction tx) {
        try (var out = new EndianAwareOutputStream(ByteOrder.LITTLE_ENDIAN)) {
            for (var input : tx.getInputs()) {
                out.write(Script.parseHex(input.getRelatedUTXO().script()).serialize(0));
            }

            return out.toByteArray();
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
    }

    private static final byte[] ONE = Hex.decode("0100000000000000000000000000000000000000000000000000000000000000");
}