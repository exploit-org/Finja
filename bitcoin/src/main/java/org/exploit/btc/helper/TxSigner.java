package org.exploit.btc.helper;

import org.exploit.btc.model.SigData;
import org.exploit.btc.model.SignatureData;
import org.exploit.btc.protocol.*;
import org.exploit.btc.protocol.script.P2PKHScript;
import org.exploit.btc.protocol.script.P2TRScript;
import org.exploit.btc.protocol.script.P2WPKHScript;
import org.exploit.crypto.Hash;
import org.exploit.crypto.key.secp256k1.Secp256k1PublicKey;
import org.exploit.finja.core.key.flag.ECFlag;

import java.util.List;
import java.util.stream.IntStream;

public final class TxSigner {
    private TxSigner() {}

    public static Transaction sign(SignatureData keyData, Transaction transaction, List<? extends UTXO> utxos, SigData sig) {
        var tx = transaction.copy();

        IntStream.range(0, tx.getInputs().size())
                .forEach(i -> innerSignInput(keyData, tx, utxos, i, sig));

        return transaction;
    }

    public static Transaction signInput(SignatureData keyData, Transaction transaction, List<? extends UTXO> utxos, int i, SigData sig) {
        var tx = transaction.copy();
        innerSignInput(keyData, tx, utxos, i, sig);

        return tx;
    }

    private static void innerSignInput(SignatureData keyData, Transaction transaction, List<? extends UTXO> utxos, int i, SigData sig) {
        var script = keyData.getScript();
        var input = transaction.getInputs().get(i);
        var utxo = utxos.get(i);

        var publicKey = ((Secp256k1PublicKey) keyData.getSigner().getPublicKey()).tweak(new byte[0]);

        Script pubScript;

        if (script instanceof P2PKHScript)
            pubScript = Script.parseHex(utxo.script());
        else if (script instanceof P2WPKHScript)
            pubScript = Script.pay2pkh(Hash.hash160(keyData.getSigner().getPublicKey().compress()));
        else if (script instanceof P2TRScript p2tr) {
            pubScript = p2tr.createScript(publicKey.encoded());
        }
        else
            throw new IllegalArgumentException("Only P2PKH, P2WPKH and P2TR are currently supported");

        var hashForSigning = TxSignatureHelper.hashForSigning(transaction, i,
                pubScript, sig.getSigHash(), utxo.amount(), sig.getVersion());

        var flags = (script instanceof P2TRScript) ? ECFlag.USE_TAPROOT_SCHNORR : 0;
        var signature = keyData.getSigner().sign(hashForSigning, flags);
        var sigBytes = (script instanceof P2TRScript) ? signature.encode() : signature.der();

        var sigHashedBytes = new byte[sigBytes.length + 1];
        System.arraycopy(sigBytes, 0, sigHashedBytes, 0, sigHashedBytes.length - 1);
        sigHashedBytes[sigHashedBytes.length - 1] = (byte) sig.getSigHash();

        if (script.isTaproot()) {
            handleTaproot(keyData, input, sigHashedBytes);
        } else if (script.isSegWit()) {
            handleSegWit(keyData, input, sigHashedBytes);
        } else {
            handleDefault(keyData, input, sigHashedBytes);
        }
    }

    private static void handleTaproot(SignatureData keyData, TxIn input, byte[] signature) {
        var witness = new ScriptWitness()
                .push(signature);

        input.setScriptWitness(witness);
    }

    private static void handleSegWit(SignatureData keyData, TxIn input, byte[] signature) {
        var witness = new ScriptWitness()
                .push(signature)
                .push(keyData.getSigner().getPublicKey().compress());

        input.setScriptWitness(witness);
    }

    private static void handleDefault(SignatureData keyData, TxIn input, byte[] signature) {
        var signatureScript = keyData.getScript().createSignatureScript(signature, keyData.getSigner().getPublicKey());
        input.setSignatureScript(signatureScript);
    }
}
