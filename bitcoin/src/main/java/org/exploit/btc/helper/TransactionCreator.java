package org.exploit.btc.helper;

import org.exploit.btc.BitcoinProtocolProvider;
import org.exploit.btc.constant.TxFormat;
import org.exploit.btc.protocol.Transaction;
import org.exploit.btc.protocol.TxOut;
import org.exploit.btc.protocol.UTXO;
import org.exploit.btc.protocol.script.BitcoinScript;
import org.exploit.finja.core.constant.AmountUnit;
import org.exploit.finja.core.constant.Asset;
import org.exploit.finja.core.constant.Flag;
import org.exploit.finja.core.exception.NotEnoughBalanceException;
import org.exploit.finja.core.model.Amount;
import org.exploit.finja.core.model.Recipient;

import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.Comparator;
import java.util.List;

public class TransactionCreator {
    private final BitcoinProtocolProvider provider;

    public TransactionCreator(BitcoinProtocolProvider provider) {
        this.provider = provider;
    }

    public Transaction createTransaction(
            Asset asset,
            TxFormat format, String changeAddress,
            List<? extends UTXO> utxos, List<Recipient> recipients,
            int flags
    ) {
        var transaction = new Transaction();

        var totalAmount = recipients.stream()
                .map(Recipient::getAmount)
                .map(this::calculateTxAmount)
                .mapToLong(BigInteger::longValue)
                .sum();

        var transactionAmount = BigInteger.valueOf(totalAmount);

        var totalInput = processInputs(utxos, transaction, transactionAmount);

        for (var recipient : recipients) {
            var scriptTo = provider.getScript(recipient.getAddress());
            addDestinationOutput(transaction, calculateTxAmount(recipient.getAmount()), scriptTo, recipient.getAddress());
        }

        transaction.setFormat(format);

        var feePolicy = provider.meta().feePolicy();

        var satPerByte = provider.feeProvider().estimate(feePolicy);
        var finalSatPerByte = satPerByte.compareTo(MIN_SAFE_FEE) > 0 ? satPerByte : MIN_SAFE_FEE;
        var fee = transaction.estimateFee(finalSatPerByte);
        transaction.setFee(fee.longValue());

        adjustTransactionForFee(transaction, recipients, totalInput,
                BigInteger.valueOf(totalAmount), fee, flags);

        var finalTransactionAmount = transaction.getOutputs().stream()
                .map(TxOut::amount)
                .reduce(BigInteger.ZERO, BigInteger::add);

        var change = totalInput.subtract(finalTransactionAmount).subtract(fee);

        applyChange(asset, changeAddress, transaction, change);

        return transaction;
    }

    private void adjustTransactionForFee(Transaction transaction, List<Recipient> recipients, BigInteger totalInput, BigInteger totalAmount, BigInteger fee, int flags) {
        if ((flags & Flag.INCLUDE_FEE) != 0) {
            var totalOutputs = recipients.stream()
                    .map(recipient -> calculateTxAmount(recipient.getAmount()))
                    .reduce(BigInteger.ZERO, BigInteger::add);

            transaction.getOutputs().clear();

            for (var recipient : recipients) {
                var recipientAmount = calculateTxAmount(recipient.getAmount());

                var feeShare = recipientAmount.multiply(fee).divide(totalOutputs);
                var newAmount = recipientAmount.subtract(feeShare);

                if (newAmount.compareTo(BigInteger.ZERO) < 0) {
                    throw new IllegalArgumentException("Adjustment results in negative amount for recipient");
                }

                var address = recipient.getAddress();
                var scriptTo = provider.getScript(address);

                addDestinationOutput(transaction, newAmount, scriptTo, address);
            }
        } else {
            var totalCost = totalAmount.add(fee);

            if (totalInput.compareTo(totalCost) < 0) {
                throw new NotEnoughBalanceException("Not enough balance to cover the transaction amount and the fee.");
            }
        }
    }

    private BigInteger processInputs(List<? extends UTXO> utxos, Transaction transaction, BigInteger transactionAmount) {
        var totalInput = BigInteger.ZERO;

        var sortedUtxos = utxos.stream().sorted(Comparator.comparing(UTXO::amount).reversed())
                .toList();

        for (var utxo : sortedUtxos) {
            if (totalInput.longValue() >= transactionAmount.longValue() * 1.2)
                break;

            transaction.addInput(utxo.createInput());
            totalInput = totalInput.add(BigInteger.valueOf(utxo.amount()));
        }

        return totalInput;
    }

    private void applyChange(Asset asset, String changeAddress, Transaction transaction, BigInteger change) {
        if (change.compareTo(BigInteger.ZERO) > 0) {
            addChangeOutput(asset, changeAddress, transaction, change);
        } else if (change.compareTo(BigInteger.ZERO) < 0) {
            throw new NotEnoughBalanceException("Not enough balance including fee");
        }
    }

    private BigInteger calculateTxAmount(Amount amount) {
        return amount.amountUnit() == AmountUnit.HUMAN ? provider.converter().toUnit(amount.value()) :
                amount.value().toBigInteger();
    }

    private void addChangeOutput(Asset asset, String changeAddress, Transaction transaction, BigInteger change) {
        var changeScript = provider.getScript(changeAddress);
        var out = new TxOut(true, change, changeScript.createScript(changeScript.extractHash(changeAddress)));

        transaction.addOutput(out);
    }

    private void addDestinationOutput(Transaction transaction, BigInteger transactionAmount, BitcoinScript scriptTo, String to) {
        var outTo = new TxOut(transactionAmount, scriptTo.createScript(scriptTo.extractHash(to)));
        transaction.addOutput(outTo);
    }

    public static TransactionCreator create(BitcoinProtocolProvider provider) {
        return new TransactionCreator(provider);
    }

    private static final BigDecimal MIN_SAFE_FEE = new BigDecimal("1.5");
}
