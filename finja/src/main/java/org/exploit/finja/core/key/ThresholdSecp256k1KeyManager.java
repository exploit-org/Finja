package org.exploit.finja.core.key;

import lombok.AllArgsConstructor;
import org.exploit.crypto.key.ECPublicKey;
import org.exploit.crypto.key.secp256k1.Secp256k1PublicKey;
import org.exploit.finja.core.key.flag.ECFlag;
import org.exploit.secp256k1.Secp256k1PointOps;

import org.exploit.tkeeper.sdk.TKeeperClient;
import org.exploit.tkeeper.sdk.model.SessionType;
import org.exploit.tkeeper.sdk.model.Sign;
import org.exploit.tkeeper.sdk.model.context.TaprootContext;
import org.exploit.tss.signature.ECDSASignature;
import org.exploit.tss.signature.SchnorrSignature;
import org.exploit.tss.signature.Signature;

import java.util.Arrays;
import java.util.Base64;
import java.util.Map;
import java.util.UUID;

@AllArgsConstructor
public class ThresholdSecp256k1KeyManager implements ECKeyManager<Secp256k1PointOps> {
    private final String keyId;
    private final TKeeperClient client;

    @Override
    public Signature sign(byte[] data, int flags) {
        var isTaproot = (flags & ECFlag.USE_TAPROOT_SCHNORR) != 0;

        var context = isTaproot ? new TaprootContext(null)
                : null;

        var algorithm = isTaproot ? SessionType.FROST : SessionType.GG20;

        if ((flags & ECFlag.USE_TAPROOT_SCHNORR) != 0)
           throw new UnsupportedOperationException("Taproot Schnorr signing currently is not supported in threshold mode.");

        var opId = UUID.randomUUID().toString();
        var request = new Sign(keyId, algorithm, Map.of(opId, Base64.getEncoder().encodeToString(data)), false, context);
        var signatures = client.signature().sign(request).signature();

        var signature = Base64.getDecoder().decode(signatures.get(opId));
        var r = Arrays.copyOfRange(signature, 0, 32);
        var s = Arrays.copyOfRange(signature, 32, 64);

        if (isTaproot) {
            return new SchnorrSignature(r, s);
        }

        var recId = signature[64];

        return new ECDSASignature(r, s, recId);
    }

    @Override
    public ECPublicKey<Secp256k1PointOps> getPublicKey() {
        var dto = client.central().getPublicKey(keyId);
        var decoded = Base64.getDecoder().decode(dto.data64());

        return new Secp256k1PublicKey(decoded);
    }

    @Override
    public void erase() {}
}
