package org.exploit.finja.core.key;

import lombok.AllArgsConstructor;
import org.exploit.crypto.key.ECPublicKey;
import org.exploit.crypto.key.secp256k1.Secp256k1PublicKey;
import org.exploit.finja.core.key.flag.ECFlag;
import org.exploit.secp256k1.Secp256k1PointOps;
import org.exploit.tsec.TSecurityClient;
import org.exploit.tsec.constant.CurveName;
import org.exploit.tsec.constant.SessionType;
import org.exploit.tsec.constant.SigType;
import org.exploit.tsec.exception.KeeperException;
import org.exploit.tsec.model.OperationsDto;
import org.exploit.tsec.model.Sign;
import org.exploit.tsec.signature.DecodedECDSASignature;
import org.exploit.tss.signature.ECDSASignature;
import org.exploit.tss.signature.Signature;

import java.util.Base64;
import java.util.Map;
import java.util.UUID;

@AllArgsConstructor
public class ThresholdSecp256k1KeyManager implements ECKeyManager<Secp256k1PointOps> {
    private final String keyId;
    private final TSecurityClient client;

    @Override
    public Signature sign(byte[] data, int flags) {
        if ((flags & ECFlag.USE_TAPROOT_SCHNORR) != 0)
           throw new UnsupportedOperationException("Taproot Schnorr signing currently is not supported in threshold mode.");

        var opId = UUID.randomUUID().toString();
        var ops = new OperationsDto(Map.of(opId, Base64.getEncoder().encodeToString(data)));

        var request = Sign.newBuilder()
                .operations(ops)
                .keyId(keyId)
                .type(SessionType.GG20)
                .sigType(SigType.ECDSA)
                .curve(CurveName.SECP256K1)
                .build();

        var response = client.sign(request);
        var decodedSignature = response.getSignature()
                .getSignatures()
                .get(opId);

        if (!(decodedSignature instanceof DecodedECDSASignature ecdsa)) {
            throw new KeeperException("No signature found for operation ID: " + opId);
        }

        return new ECDSASignature(ecdsa.r(), ecdsa.s(), ecdsa.recId());
    }

    @Override
    public ECPublicKey<Secp256k1PointOps> getPublicKey() {
        var dto = client.publicKey(keyId);
        var decoded = Base64.getDecoder().decode(dto.getData64());

        return new Secp256k1PublicKey(decoded);
    }

    @Override
    public void erase() {}
}
