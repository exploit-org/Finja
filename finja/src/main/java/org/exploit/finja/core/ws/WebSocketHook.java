package org.exploit.finja.core.ws;

import io.netty.handler.codec.http.HttpHeaders;
import org.exploit.finja.core.model.WebData;
import org.exploit.finja.utils.Auth;
import org.reactivestreams.Publisher;
import reactor.core.Disposable;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import reactor.netty.http.client.HttpClient;
import reactor.netty.http.client.WebsocketClientSpec;
import reactor.netty.http.websocket.WebsocketInbound;
import reactor.netty.http.websocket.WebsocketOutbound;
import reactor.util.retry.Retry;

import java.time.Duration;
import java.util.concurrent.atomic.AtomicBoolean;

public abstract class WebSocketHook implements Bindable<WebSocketHook>, Disposable {
    private Disposable task;
    private final AtomicBoolean manualClose = new AtomicBoolean(false);

    private final WebData data;

    protected WebSocketHook(WebData data) {
        this.data = data;
    }

    public abstract Mono<Void> handle(String text);

    public abstract Publisher<Void> doOnConnected(WebsocketInbound inbound, WebsocketOutbound outbound);

    public abstract Publisher<Void> ping(WebsocketOutbound outbound);

    public abstract long pingRoundSeconds();

    public Mono<Void> beforeReconnect() {
        return Mono.empty();
    }

    @Override
    public Disposable bind() {
        manualClose.set(false);
        this.task = HttpClient.create()
                .headers(headers -> {
                    Auth.applyAuth(headers, data.auth());
                    modifyHeaders(headers);
                })
                .websocket(WebsocketClientSpec.builder().handlePing(true).build())
                .uri(Auth.buildUriWithAuth(data.wsUrl(), data.auth()))
                .handle(this::onConnected)
                .retryWhen(Retry.backoff(Long.MAX_VALUE, Duration.ofSeconds(10))
                        .doBeforeRetryAsync(signal -> beforeReconnect()))
                .doOnTerminate(() -> {
                    if (!manualClose.get())
                        this.task = bind();
                })
                .subscribe();

        return this;
    }

    public void modifyHeaders(HttpHeaders headers) {

    }

    private Mono<Void> onConnected(WebsocketInbound inbound, WebsocketOutbound outbound) {
        var thenInbound = inbound.aggregateFrames()
                .receive()
                .asString()
                .flatMap(this::handle)
                .thenMany(Flux.never());

        var ping = Flux.interval(Duration.ofSeconds(pingRoundSeconds()))
                .flatMap(tick -> ping(outbound))
                .thenMany(Flux.never());

        return Flux.merge(thenInbound, doOnConnected(inbound, outbound), ping)
                .then();
    }

    @Override
    public void dispose() {
        manualClose.set(true);

        if (task != null && !task.isDisposed())
            task.dispose();
    }
}
