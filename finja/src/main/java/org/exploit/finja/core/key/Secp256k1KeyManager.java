package org.exploit.finja.core.key;

import org.exploit.crypto.curve.Secp256k1Provider;
import org.exploit.crypto.key.ECPublicKey;
import org.exploit.crypto.key.secp256k1.Secp256k1KeyPair;
import org.exploit.crypto.key.secp256k1.Secp256k1PrivateKey;
import org.exploit.finja.core.key.flag.ECFlag;
import org.exploit.secp256k1.Secp256k1PointOps;
import org.exploit.sodium.ReadOnlyBuffer;
import org.exploit.tss.signature.Signature;

public class Secp256k1KeyManager implements ECKeyManager<Secp256k1PointOps> {
    private final Secp256k1PrivateKey privateKey;

    public Secp256k1KeyManager(ReadOnlyBuffer privateKey) {
        this.privateKey = new Secp256k1PrivateKey(privateKey);
    }

    public Secp256k1KeyManager(byte[] privateKey) {
        this(new ReadOnlyBuffer(privateKey));
    }

    @Override
    public Signature sign(byte[] data, int flags) {
        var keyPair = Secp256k1KeyPair.create(privateKey);

        if ((flags & ECFlag.USE_TAPROOT_SCHNORR) != 0)
            return Secp256k1Provider.getInstance().schnorr().sign(keyPair.privateKey(), data);

        return Secp256k1Provider.getInstance().sign(data, keyPair);
    }

    @Override
    public ECPublicKey<Secp256k1PointOps> getPublicKey() {
        return Secp256k1Provider.getInstance().getPublicKey(privateKey);
    }

    @Override
    public void erase() {
        privateKey.erase();
    }
}
