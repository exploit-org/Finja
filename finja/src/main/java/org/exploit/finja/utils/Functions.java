package org.exploit.finja.utils;

import org.exploit.crypto.utils.Pair;
import org.web3j.abi.FunctionEncoder;
import org.web3j.abi.FunctionReturnDecoder;
import org.web3j.abi.TypeReference;
import org.web3j.abi.datatypes.AbiTypes;
import org.web3j.abi.datatypes.Address;
import org.web3j.abi.datatypes.Function;
import org.web3j.abi.datatypes.Type;
import org.web3j.abi.datatypes.generated.Uint256;

import java.math.BigInteger;
import java.util.List;

public final class Functions {
    private Functions() {
    }

    public static String encodeTransfer(Address to, Uint256 value, boolean includeMethodHash) {
        var function = new Function("transfer", List.of(to, value), List.of());
        return encode(function, includeMethodHash);
    }

    public static String encodeBalance(Address address, boolean includeMethodHash) {
        var function = new Function("balanceOf", List.of(address), List.of(new TypeReference<Uint256>() {}));
        return encode(function, includeMethodHash);
    }

    public static Pair<String, BigInteger> decodeTransfer(String input) {
        try {
            var outputParams = decode(input, List.of("address", "uint256"));

            var address = (Address) outputParams.get(0);
            var uint = (Uint256) outputParams.get(1);

            return Pair.of(address.getValue(), uint.getValue());
        } catch (Exception e) {
            return null;
        }
    }

    @SuppressWarnings("unchecked")
    public static List<Type> decode(String input, List<String> types) {
        var output = "0x" + (input.startsWith("0x") ? input.substring(10) : input.substring(8));

        var abiTypes = types.stream().map(AbiTypes::getType)
                .map(TypeReference::create)
                .map(reference -> (TypeReference<Type>) reference)
                .toList();

        return FunctionReturnDecoder.decode(output, abiTypes);
    }

    public static String encode(Function function, boolean includeMethodHash) {
        var encoded = FunctionEncoder.encode(function);
        return includeMethodHash ? encoded : encoded.substring(10);
    }
}