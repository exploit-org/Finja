package org.exploit.finja.listener;

import lombok.extern.slf4j.Slf4j;
import org.exploit.finja.core.EventFetcher;
import org.exploit.finja.core.TransactionListener;
import org.exploit.finja.core.constant.Asset;
import org.exploit.finja.core.event.TxnEvent;
import org.exploit.finja.listener.config.PollingLimiterConfig;
import org.exploit.signalix.manager.EventScope;
import reactor.core.Disposable;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

import java.time.Duration;
import java.util.HashSet;
import java.util.Set;

@Slf4j
public class PollingTxListener implements TransactionListener {
    protected Disposable pollTask;
    protected final Set<PollingAddressHook> hooks = new HashSet<>();

    protected final Asset asset;
    protected final EventFetcher eventFetcher;
    protected final PollingEventRestorer restorer;
    protected final PollingLimiterConfig limiterConfig;
    protected final long pollIntervalSeconds;
    protected final EventScope eventScope;

    public PollingTxListener(Asset asset, EventFetcher eventFetcher, PollingLimiterConfig limiterConfig, long pollIntervalSeconds, EventScope eventScope) {
        this.asset = asset;
        this.eventFetcher = eventFetcher;
        this.restorer = new PollingEventRestorer(eventFetcher);
        this.limiterConfig = limiterConfig;
        this.pollIntervalSeconds = pollIntervalSeconds;
        this.eventScope = eventScope;
    }

    @Override
    public void start() {
        this.pollTask = Flux.interval(Duration.ofSeconds(pollIntervalSeconds))
                .flatMap(i -> Flux.fromIterable(hooks))
                .flatMap(hook -> eventFetcher.events(hook.getAddress(), hook.getTimestamp())
                        .collectList()
                        .map(hook::processEvents)
                        .onErrorResume(t -> {
                            log.error("Couldn't poll from address: {}", hook.getAddress(), t);
                            return Mono.empty();
                        }), limiterConfig.getMaxPerUpdate()
                )
                .delayElements(Duration.ofMillis(limiterConfig.getDelay()))
                .onBackpressureBuffer()
                .flatMap(Flux::fromIterable)
                .flatMap(event -> Mono.fromRunnable(() -> eventScope.call(event)))
                .onErrorResume(t -> {
                    log.error("Error occurred while polling: ", t);
                    return Mono.empty();
                })
                .subscribe();
    }

    @Override
    public void listen(String address, long timestamp) {
        hooks.add(new PollingAddressHook(address, timestamp));
    }

    @Override
    public void removeListener(String address) {
        hooks.removeIf(hook -> hook.getAddress().equals(address));
    }

    @Override
    public Flux<TxnEvent> restore(String address, long timestamp) {
        return restorer.restore(hooks, address, timestamp);
    }

    @Override
    public void dispose() {
        if (pollTask != null)
            pollTask.dispose();
    }

    @Override
    public Asset asset() {
        return asset;
    }
}
