package org.exploit.tron.service;

import org.exploit.finja.core.SmartCoinBalanceService;
import org.exploit.finja.core.model.Value;
import org.exploit.finja.utils.Jackson;
import org.exploit.tron.TronProvider;
import org.exploit.tron.protocol.Account;
import org.exploit.tron.protocol.AccountModel;
import org.exploit.tron.protocol.TriggerSmartContract;
import org.exploit.tron.utils.TronKeys;
import org.web3j.abi.FunctionEncoder;
import org.web3j.abi.TypeReference;
import org.web3j.abi.datatypes.Address;
import org.web3j.abi.datatypes.Function;
import org.web3j.abi.datatypes.generated.Uint256;

import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.List;

public class BalanceService implements SmartCoinBalanceService {
    private final TronProvider provider;

    public BalanceService(TronProvider provider) {
        this.provider = provider;
    }

    @Override
    public Value balance(String visibleAddress) {
        var accountNode = provider.client().getAccount(new AccountModel(visibleAddress, true));
        if (accountNode.isEmpty())
            return new Value(BigDecimal.ZERO, BigInteger.ZERO);

        var account = Jackson.convert(accountNode, Account.class);
        var balance = account.balance();

        var humanBalance = provider.converter().toHuman(BigInteger.valueOf(balance));

        return new Value(humanBalance, BigInteger.valueOf(balance));
    }

    @Override
    public Value balance(String visibleAddress, String contractAddress) {
        var hexVisible = "0x" + TronKeys.hexNoPrefix(visibleAddress);

        var function = new Function(
                "balanceOf",
                List.of(new Address(hexVisible)),
                List.of(new TypeReference<Uint256>() {})
        );

        var encoded = FunctionEncoder.encode(function).substring(10);

        var contract = new TriggerSmartContract();
        contract.setOwnerAddress(TronKeys.hex(visibleAddress));
        contract.setContractAddress(TronKeys.hex(contractAddress));
        contract.setParameter(encoded);
        contract.setFunctionSelector(BALANCE_SELECTOR);
        contract.setVisible(false);

        var triggerResult = provider.client().triggerConstantContract(contract);

        if (triggerResult.isEmpty())
            return new Value(BigDecimal.ZERO, BigInteger.ZERO);

        var balance = new BigInteger(triggerResult.get("constant_result").get(0).asText(), 16);
        var humanBalance = provider.converter().toHuman(balance, contractAddress);

        return new Value(humanBalance, balance);
    }

    private static final String BALANCE_SELECTOR = "balanceOf(address)";
}
