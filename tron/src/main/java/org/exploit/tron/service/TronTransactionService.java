package org.exploit.tron.service;

import org.bouncycastle.util.encoders.Hex;
import org.exploit.crypto.Hash;
import org.exploit.crypto.utils.Pair;
import org.exploit.finja.core.OutgoingTransaction;
import org.exploit.finja.core.constant.AmountUnit;
import org.exploit.finja.core.constant.Flag;
import org.exploit.finja.core.contract.SolidityContract;
import org.exploit.finja.core.contract.transaction.SmartTransaction;
import org.exploit.finja.core.contract.transaction.SmartTransactionService;
import org.exploit.finja.core.exception.NotEnoughBalanceException;
import org.exploit.finja.core.exception.TransactionSendException;
import org.exploit.finja.core.key.ECKeyManager;
import org.exploit.finja.core.model.Amount;
import org.exploit.finja.core.model.Receipt;
import org.exploit.finja.core.model.Recipient;
import org.exploit.finja.stereotype.Sensitive;
import org.exploit.finja.utils.Jackson;
import org.exploit.tron.TronProvider;
import org.exploit.tron.address.TronWallet;
import org.exploit.tron.constant.Constant;
import org.exploit.tron.contract.TronMultiTransferContract;
import org.exploit.tron.protocol.AccountModel;
import org.exploit.tron.protocol.TriggerSmartContract;
import org.exploit.tron.protocol.TronOutgoing;
import org.exploit.tron.protocol.builder.RawDataBuilder;
import org.exploit.tron.protocol.transaction.*;
import org.exploit.tron.utils.TronKeys;
import org.web3j.abi.FunctionEncoder;
import org.web3j.abi.datatypes.Address;
import org.web3j.abi.datatypes.DynamicArray;
import org.web3j.abi.datatypes.Function;
import org.web3j.abi.datatypes.generated.Uint256;

import java.math.BigDecimal;
import java.math.BigInteger;
import java.time.Instant;
import java.util.ArrayList;
import java.util.List;

public class TronTransactionService implements Sensitive, SmartTransactionService {
    private static final String TRANSFER_SELECTOR = "transfer(address,uint256)";

    private final TronProvider provider;
    private final ECKeyManager keyManager;

    public TronTransactionService(TronProvider provider, ECKeyManager keyManager) {
        this.provider = provider;
        this.keyManager = keyManager;
    }

    @Override
    public TronOutgoing sign(SmartTransaction transaction) {
        if (!(transaction instanceof Transaction tx))
            throw new IllegalArgumentException("Unsupported TRON transaction type: " + transaction.getClass().getName());

        if (!tx.signature().isEmpty())
            tx.signature().clear();

        var dataHash = Hash.sha256(Hex.decode(tx.rawDataHex()));
        var signature = keyManager.sign(dataHash).encode();

        tx.signature().add(Hex.toHexString(signature));

        return new TronOutgoing(tx, this);
    }

    @Override
    public void erase() {
        keyManager.erase();
    }

    public OutgoingTransaction multiSend(TronWallet from, List<Recipient> recipients, int flags) {
        var contract = provider.findContract(TronMultiTransferContract.class);

        if (contract == null)
            throw new IllegalStateException("MultiTransfer contract is not registered");

        var receiverList = getReceiverAddresses(recipients);
        var amountsList = getAmountsList(recipients);

        var function = createMultiSendFunction("send", receiverList, amountsList);
        var trigger = multiSendContract(from, contract, function);

        var totalFee = provider.client().estimateSunConsumption(trigger);

        var tx = (shouldIncludeFee(flags)) ? adjustForFeeAndCall(contract, from, receiverList, amountsList, totalFee)
                : callContract(contract, from, function, totalFee);

        return sign(tx);
    }

    public Receipt sendTransaction(Transaction transaction) {
        var broadcast = provider.client().broadcast(transaction);
        if (!broadcast.result()) {
            throw new TransactionSendException(broadcast.code() + " : " + broadcast.message());
        }

        return receipt(transaction);
    }

    public OutgoingTransaction sendTransaction(String from, String to, Amount amount, int flags) {
        var value = amount.asUnit(provider);

        var fromHex = TronKeys.hex(from);
        var toHex = TronKeys.hex(to);

        var rawData = buildRawTransaction(fromHex, toHex, value.longValue());
        var bandwidth = provider.client().getFreeNet(fromHex, false);

        var fee = calculateFee(rawData.build().hex(), bandwidth);
        var totalFee = calculateTotalFee(toHex, fee);

        return buildOutTransfer(rawData, value.longValue(), totalFee, fromHex, toHex, flags);
    }

    public OutgoingTransaction multiSend(TronWallet address, String contractAddress, List<Recipient> recipients) {
        var contract = provider.findContract(TronMultiTransferContract.class);

        if (contract == null)
            throw new IllegalStateException("MultiTransfer contract is not registered");

        var pairs = recipients.stream()
                .map(recipient -> {
                    var targetAddress = new Address(recipient.getAddress());
                    var amount = recipient.getAmount().asUnit(provider);

                    return Pair.of(targetAddress, amount);
                })
                .toList();

        var receivers = new DynamicArray(pairs.stream().map(Pair::first).toList());
        var amounts = new DynamicArray(pairs.stream().map(Pair::second).toList());

        return contract.execute(address, "sendToken", List.of(
                new Address(contractAddress), receivers, amounts
        ));
    }

    public RawDataBuilder rawDataBuilder() {
        var now = Instant.now();
        var block = provider.client().getNowBlock();

        return RawData.newBuilder()
                .refBlockBytes(Hex.toHexString(block.calcRefBlockBytes()))
                .refBlockHash(Hex.toHexString(block.calcRefBlockHash()))
                .timestamp(now.toEpochMilli())
                .expiration(now.plusSeconds(60).toEpochMilli());
    }

    private RawDataBuilder buildRawTransaction(String fromHex, String toHex, long value) {
        return rawDataBuilder().addContract(createTransferContract(fromHex, toHex, value));
    }

    private long calculateFee(String rawDataHex, long bandwidth) {
        var sunValue = provider.converter().toUnit(BigDecimal.TEN).longValue();
        return Math.max((Hex.decode(rawDataHex).length - bandwidth) * sunValue, 0);
    }

    private Long calculateTotalFee(String toHex, long fee) {
        return provider.client().isActivated(new AccountModel(toHex, false)) ? fee
                : provider.client().getSystemAccountActivationFee() + fee;
    }

    private OutgoingTransaction buildOutTransfer(
            RawDataBuilder rawData, long value, long totalFee,
            String fromHex, String toHex, int flags
    ) {
        Transaction tx;

        if ((flags & Flag.INCLUDE_FEE) != 0) {
            var finalAmount = value - totalFee;

            if (finalAmount < 0)
                throw new NotEnoughBalanceException("Not enough balance for TRX transfer");

            var finalRawData = rawData.removeContract(0)
                    .addContract(createTransferContract(fromHex, toHex, finalAmount))
                    .build();

            tx = buildTransactionFromRawData(finalRawData);
        } else {
            tx = buildTransactionFromRawData(rawData.build());
        }

        tx.setFee(totalFee);
        return sign(tx);
    }

    private Contract createTransferContract(String fromHex, String toHex, long value) {
        var param = Jackson.toNode(new TransferContractValue(value, fromHex, toHex));

        return new Contract(new Parameter(param, Constant.TRANSFER_TYPE_URL), Constant.TRANSFER_CONTRACT);
    }

    private List<Address> getReceiverAddresses(List<Recipient> recipients) {
        return recipients.stream()
                .map(r -> new Address(TronKeys.hexNoPrefix(r.getAddress())))
                .toList();
    }

    private List<Uint256> getAmountsList(List<Recipient> recipients) {
        return recipients.stream()
                .map(r -> new Uint256(r.getAmount().asUnit(provider)))
                .toList();
    }

    private Function createMultiSendFunction(String functionName, List<Address> receiverList, List<Uint256> amountsList) {
        return new Function(functionName, List.of(
                new DynamicArray<>(Address.class, receiverList),
                new DynamicArray<>(Uint256.class, amountsList)
        ), List.of());
    }

    private TriggerSmartContract multiSendContract(TronWallet from, SolidityContract contract, Function function) {
        var encoded = FunctionEncoder.encode(function).substring(10);

        return new TriggerSmartContract() {{
            setVisible(true);
            setOwnerAddress(from.publicAddress());
            setContractAddress(contract.getContractAddress());
            setFunctionSelector("send(address[],uint256[])");
            setParameter(encoded);
        }};
    }

    private boolean shouldIncludeFee(int flags) {
        return (flags & Flag.INCLUDE_FEE) != 0;
    }

    private Transaction adjustForFeeAndCall(SolidityContract contract, TronWallet from, List<Address> receiverList, List<Uint256> amountsList, BigInteger totalFee) {
        var totalAmount = amountsList.stream()
                .map(Uint256::getValue)
                .reduce(BigInteger.ZERO, BigInteger::add);

        var adjustedAmountsList = amountsList.stream()
                .map(amount -> {
                    var feeShare = amount.getValue().multiply(totalFee).divide(totalAmount);
                    var newAmount = amount.getValue().subtract(feeShare);

                    if (newAmount.compareTo(BigInteger.ZERO) <= 0) {
                        throw new IllegalArgumentException("Adjusted amount is zero or negative after fee exclusion");
                    }

                    return new Uint256(newAmount);
                })
                .toList();

        var adjustedFunction = createMultiSendFunction("send", receiverList, adjustedAmountsList);

        return callContract(contract, from, adjustedFunction, totalFee);
    }

    private Transaction callContract(SolidityContract contract, TronWallet from, Function function, BigInteger totalFee) {
        TronOutgoing tx = (TronOutgoing) contract.execute(from, function.getName(), function.getInputParameters());
        tx.getTransaction().setFee(totalFee.longValue());

        return tx.getTransaction();
    }

    public Transaction buildTransactionFromRawData(RawData rawData) {
        return Transaction.newBuilder()
                .rawData(rawData)
                .rawDataHex(rawData.hex())
                .txID(rawData.txid())
                .build();
    }

    public OutgoingTransaction sendTransaction(String from, String to, String contractAddress, Amount amount) {
        var unit = amount.amountUnit() == AmountUnit.UNIT ? amount.value().toBigInteger()
                : provider.converter().toUnit(amount.value(), contractAddress);

        return createSmartOutgoing(triggerTransfer(from, to, contractAddress, unit));
    }

    private TronOutgoing createSmartOutgoing(TriggerSmartContract triggerContract) {
        var tronClient = provider.client();
        var totalFee = tronClient.estimateSunConsumption(triggerContract);
        triggerContract.setFeeLimit(totalFee.longValue());

        var transaction = tronClient.triggerSmartContract(triggerContract).transaction();
        transaction.setFee(totalFee.longValue());

        return new TronOutgoing(transaction, this);
    }

    private TriggerSmartContract triggerTransfer(String from, String to, String contract, BigInteger value) {
        var function = new Function(
                "transfer",
                List.of(new Address(TronKeys.hexNoPrefix(to)), new Uint256(value)),
                new ArrayList<>()
        );

        var encoded = FunctionEncoder.encode(function)
                .substring(10);

        var fromHex = TronKeys.hex(from);
        var contractHex = TronKeys.hex(contract);

        return new TriggerSmartContract() {{
            setOwnerAddress(fromHex);
            setContractAddress(contractHex);
            setParameter(encoded);
            setFunctionSelector(TRANSFER_SELECTOR);
            setVisible(false);
        }};
    }

    private Receipt receipt(Transaction transaction) {
        var tx = provider.client().getTransactionById(transaction.txID());
        var rets = transaction.ret();

        if (rets.isEmpty())
            return new Receipt(transaction.txID(), 0L);

        var ret = rets.get(0);

        if (!ret.getContractRet().equals("SUCCESS"))
            throw new TransactionSendException("Transaction reverted");

        return new Receipt(transaction.txID(), Math.max(transaction.getFee(), ret.getFee()));
    }
}
