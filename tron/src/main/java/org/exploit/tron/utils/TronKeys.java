package org.exploit.tron.utils;

import at.favre.lib.bytes.Bytes;
import org.bouncycastle.util.BigIntegers;
import org.bouncycastle.util.encoders.Hex;
import org.exploit.crypto.Base58;
import org.exploit.crypto.Hash;
import org.exploit.crypto.key.ECPublicKey;

import java.math.BigInteger;
import java.util.Arrays;

public final class TronKeys {
    private TronKeys() {
    }

    public static String getAddress(ECPublicKey publicKey) {
        var keyBytes = publicKey.encoded();
        var rawPublicKey = BigIntegers.asUnsignedByteArray(
                new BigInteger(1, keyBytes)
        );

        var hashedBytes = Hash.keccak256(rawPublicKey);

        var lastBytes = Arrays.copyOfRange(hashedBytes, hashedBytes.length - 20, hashedBytes.length);
        var addressNoChecksum = Bytes.from((byte) 0x41).append(lastBytes)
                .array();

        var checksum = Hash.checksum(addressNoChecksum);

        return Base58.getInstance().encode(Bytes.wrap(addressNoChecksum).append(checksum).array());
    }

    public static String visible(String hex) {
        var raw = Hex.decode(hex);
        var checksum = Hash.checksum(raw);

        return Base58.getInstance().encode(Bytes.wrap(raw).append(checksum).array());
    }

    public static String hex(String visible) {
        var decoded = Base58.getInstance().decode(visible);
        var addressNoChecksum = Arrays.copyOfRange(decoded, 0, decoded.length - 4);

        return Hex.toHexString(addressNoChecksum);
    }

    public static String hexNoPrefix(String visible) {
        return hex(visible).substring(2);
    }
}
