package org.exploit.tron.contract;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.exploit.finja.core.OutgoingTransaction;
import org.exploit.finja.core.SmartContractWallet;
import org.exploit.finja.core.contract.SolidityContract;
import org.exploit.finja.core.contract.transaction.ContractCall;
import org.exploit.finja.core.exception.TransactionSendException;
import org.exploit.finja.core.model.Receipt;
import org.exploit.finja.utils.Jackson;
import org.exploit.tron.address.TronWallet;
import org.exploit.tron.constant.Constant;
import org.exploit.tron.protocol.transaction.Contract;
import org.exploit.tron.protocol.transaction.Parameter;
import org.exploit.tron.protocol.transaction.Transaction;
import org.exploit.tron.protocol.transaction.TriggerSmartContractValue;
import org.exploit.tron.utils.TronKeys;
import org.web3j.abi.FunctionEncoder;
import org.web3j.abi.datatypes.Address;
import org.web3j.abi.datatypes.DynamicArray;
import org.web3j.abi.datatypes.Function;
import org.web3j.abi.datatypes.Type;
import org.web3j.abi.datatypes.generated.Uint256;

import java.math.BigInteger;
import java.util.Collections;
import java.util.List;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class TronMultiTransferContract implements SolidityContract {
    public static final String SEND = "send";
    public static final String SEND_TOKEN = "sendToken";

    private String contractAddress;

    @Override
    public OutgoingTransaction execute(SmartContractWallet wallet, String functionName, List<Type> args) {
        if (!(wallet instanceof TronWallet tronWallet)) {
            throw new IllegalArgumentException("Wallet should be TronWallet");
        }

        var transaction = switch (functionName) {
            case SEND -> send(tronWallet, args);
            case SEND_TOKEN -> sendToken(tronWallet, args);
            default -> throw new IllegalArgumentException("Unknown function: " + functionName);
        };

        return wallet.transactions().sign(transaction);
    }

    @Override
    public ContractCall call(SmartContractWallet wallet, String functionName, List<Type> args) {
        return null;
    }

    private Transaction send(TronWallet address, List<Type> args) {
        return createOutgoingTransaction(address, "send", args);
    }

    private Transaction sendToken(TronWallet address, List<Type> args) {
        var tokenContract = (Address) args.get(0);
        var amounts = (DynamicArray<Uint256>) args.get(2);

        var totalAmount = amounts.getValue().stream()
                .map(Uint256::getValue)
                .reduce(BigInteger.ZERO, BigInteger::add);

        var receipt = approve(address, tokenContract.getValue(), totalAmount);
        if (receipt.txid() == null)
            throw new TransactionSendException("Couldn't approve %s to spend %s".formatted(tokenContract, totalAmount));

        return createOutgoingTransaction(address, "sendToken", args);
    }

    private Transaction createOutgoingTransaction(TronWallet address, String functionName, List<Type> args) {
        var function = new Function(functionName, args, Collections.emptyList());
        var encoded = FunctionEncoder.encode(function);

        return createTransaction(address, encoded, TronKeys.hexNoPrefix(contractAddress));
    }

    private Transaction createTransaction(TronWallet address, String encodedFunction, String contractAddressHex) {
        var builder = address.transactions().rawDataBuilder();

        var trigger = new TriggerSmartContractValue(
                encodedFunction, TronKeys.hexNoPrefix(address.publicAddress()), contractAddressHex
        );

        var parameter = new Parameter(Jackson.toNode(trigger), Constant.TRIGGER_SMART_CONTRACT_TYPE_URL);
        var contract = new Contract(parameter, Constant.TRIGGER_SMART_CONTRACT);

        var rawData = builder.addContract(contract).build();

        return address.transactions().buildTransactionFromRawData(rawData);
    }

    private Receipt approve(TronWallet address, String tokenContractHex, BigInteger totalAmount) {
        var function = new Function("approve", List.of(
                new Address(tokenContractHex), new Uint256(totalAmount)
        ), Collections.emptyList());

        var encoded = FunctionEncoder.encode(function);

        var tx = createTransaction(address, encoded, TronKeys.hexNoPrefix(contractAddress));
        var outgoing = address.transactions().sign(tx);

        return outgoing.send();
    }

    @Override
    public String getContractAddress() {
        return contractAddress;
    }
}
