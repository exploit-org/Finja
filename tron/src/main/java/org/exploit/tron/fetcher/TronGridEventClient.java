package org.exploit.tron.fetcher;

import com.fasterxml.jackson.databind.node.NullNode;
import org.exploit.finja.core.EventClient;
import org.exploit.finja.core.EventFetcher;
import org.exploit.finja.core.model.WebData;
import org.exploit.tron.TronProvider;
import org.exploit.tron.api.trongrid.TronGridApi;
import org.exploit.tron.model.trongrid.ContractTransaction;
import org.exploit.tron.protocol.transaction.Transaction;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

import java.util.List;

public class TronGridEventClient implements EventClient<TronProvider> {
    private final TronGridApi api;

    public TronGridEventClient(WebData webData) {
        this.api = webData.newApiClient(TronGridApi.class);
    }

    public Flux<Transaction> transactions(String address, long minTimeStamp) {
        return fetchTransactions(address, null, minTimeStamp);
    }

    public Flux<ContractTransaction> trc20(String address, long minTimeStamp) {
        return fetchTrc20(address, null, minTimeStamp);
    }

    private Flux<ContractTransaction> fetchTrc20(String address, String fingerprint, long minTimeStamp) {
        return Mono.fromCallable(() -> api.trc20(address, fingerprint))
                .flatMapMany(transactions -> {
                    var rawTxs = transactions.data();

                    var currentTransactions = Flux.fromIterable(rawTxs)
                            .filter(transaction -> transaction.getBlockTimestamp() >= minTimeStamp);

                    var stop = hasOlderThanSmart(minTimeStamp, rawTxs);

                    var meta = transactions.meta();
                    var newFingerprint = meta.get("fingerprint");

                    if (newFingerprint == null || newFingerprint instanceof NullNode || stop) {
                        return currentTransactions;
                    } else {
                        return currentTransactions.concatWith(fetchTrc20(address, newFingerprint.asText(), minTimeStamp));
                    }
                });
    }

    private Flux<Transaction> fetchTransactions(String address, String fingerprint, long minTimeStamp) {
        return Mono.fromCallable(() -> api.transactions(address, fingerprint))
                .flatMapMany(transactions -> {
                    var meta = transactions.meta();
                    var newFingerprint = meta.get("fingerprint");

                    var rawTxs = transactions.data();

                    var currentTransactions = Flux.fromIterable(rawTxs)
                            .filter(transaction -> transaction.rawData().getTimestamp() >= minTimeStamp);

                    var stop = hasOlderThan(minTimeStamp, rawTxs);

                    if (newFingerprint == null || newFingerprint instanceof NullNode || stop) {
                        return currentTransactions;
                    } else {
                        return currentTransactions.concatWith(fetchTransactions(address, newFingerprint.asText(), minTimeStamp));
                    }
                });
    }

    @Override
    public EventFetcher createEventFetcher(TronProvider provider) {
        return new TronGridEventFetcher(provider, this);
    }

    private boolean hasOlderThan(long minTimeStamp, List<Transaction> transactions) {
        return transactions.stream()
                .anyMatch(tx -> tx.rawData().getTimestamp() < minTimeStamp);
    }

    private boolean hasOlderThanSmart(long minTimeStamp, List<ContractTransaction> transactions) {
        return transactions.stream()
                .anyMatch(tx -> tx.getBlockTimestamp() < minTimeStamp);
    }
}
