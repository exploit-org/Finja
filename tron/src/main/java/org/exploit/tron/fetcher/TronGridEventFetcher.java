package org.exploit.tron.fetcher;

import lombok.AllArgsConstructor;
import org.exploit.finja.core.EventFetcher;
import org.exploit.finja.core.constant.Asset;
import org.exploit.finja.core.constant.TxType;
import org.exploit.finja.core.event.TxnEvent;
import org.exploit.finja.core.model.Value;
import org.exploit.finja.utils.Functions;
import org.exploit.finja.utils.Jackson;
import org.exploit.tron.TronProvider;
import org.exploit.tron.model.trongrid.ContractTransaction;
import org.exploit.tron.protocol.Block;
import org.exploit.tron.protocol.transaction.Contract;
import org.exploit.tron.protocol.transaction.Transaction;
import org.exploit.tron.protocol.transaction.TransferContractValue;
import org.exploit.tron.protocol.transaction.TriggerSmartContractValue;
import org.exploit.tron.stereotype.TrxTransaction;
import org.exploit.tron.utils.TronKeys;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

import java.math.BigInteger;
import java.util.Optional;

import static org.exploit.tron.constant.Constant.*;

@AllArgsConstructor
public class TronGridEventFetcher implements EventFetcher {
    private final TronProvider provider;
    private final TronGridEventClient tronGrid;

    @Override
    public Flux<TxnEvent> events(String address, long startTimestamp) {
        return Mono.fromCallable(() -> provider.client().getLastConfirmedBlock()).flatMapMany(block ->
                Flux.concat(txs(address, block, startTimestamp), trc20(address, block, startTimestamp))
        );
    }

    private Flux<TxnEvent> txs(String address, Block block, long startTimestamp) {
        return tronGrid.transactions(address, startTimestamp)
                .flatMap(tx -> convert(numberOf(block), address, tx));
    }

    private Flux<TxnEvent> trc20(String address, Block block, long startTimestamp) {
        return tronGrid.trc20(address, startTimestamp)
                .flatMap(tx -> convert(numberOf(block), address, tx));
    }

    private Flux<TxnEvent> convert(long currentBlock, String address, TrxTransaction tx) {
        var client = provider.client();

        if (tx instanceof Transaction tronTransaction)
            return processRawTx(currentBlock, address, tronTransaction);
        else if (tx instanceof ContractTransaction contractTx)
            return Mono.fromCallable(() -> client.getTransactionById(contractTx.getTransactionId()))
                    .zipWith(Mono.fromCallable(() -> client.getTransactionInfoById(contractTx.getTransactionId())))
                    .flatMapMany(tuple -> {
                        var transaction = tuple.getT1();
                        var info = tuple.getT2();

                        transaction.setBlockNumber(info.blockNumber());

                        return processRawTx(currentBlock, address, transaction);
                    });
        else return Flux.empty();
    }

    private Flux<TxnEvent> processRawTx(long currentBlock, String address, Transaction tronTransaction) {
        return Flux.fromIterable(tronTransaction.rawData().getContract())
                .flatMap(contract -> processContract(currentBlock, tronTransaction, address, contract));
    }

    private Mono<TxnEvent> processContract(long currentBlock, Transaction tx, String address, Contract contract) {
        var type = contract.type();

        return switch (type) {
            case TRANSFER_CONTRACT -> Mono.just(handleTransfer(currentBlock, tx, address, contract));
            case TRIGGER_SMART_CONTRACT -> Mono.justOrEmpty(handleSmartContract(currentBlock, tx, address, contract));
            default -> Mono.empty();
        };
    }

    private TxnEvent handleTransfer(long currentBlock, Transaction tx, String address, Contract contract) {
        var param = Jackson.convert(contract.parameter().value(), TransferContractValue.class);

        var txType = param.ownerAddress().equals(address) ? TxType.SEND : TxType.RECEIVE;
        var value = valueOf(param.amount());

        var confirmations = confirmations(currentBlock, tx.blockNumber());

        return TxnEvent.builder()
                .type(txType)
                .asset(Asset.TRX)
                .txid(tx.txID())
                .value(value)
                .address(address)
                .confirmations(confirmations)
                .timestamp(timestamp(tx))
                .build();
    }

    private Optional<TxnEvent> handleSmartContract(long currentBlock, Transaction tx, String address, Contract contract) {
        var param = Jackson.convert(contract.parameter().value(), TriggerSmartContractValue.class);
        var data = param.data();

        if (!data.startsWith(TRANSFER_METHOD_HASH))
            return Optional.empty();

        var confirmations = confirmations(currentBlock, tx.blockNumber());
        var transfer = Functions.decodeTransfer(data);

        var to = TronKeys.visible("41" + transfer.first().substring(2));
        var value = valueOf(transfer.second());

        var type = to.equals(address) ? TxType.RECEIVE : TxType.SEND;
        var event = TxnEvent.builder()
                .type(type)
                .asset(Asset.TRX)
                .txid(tx.txID())
                .value(value)
                .address(address)
                .smartContract(param.contractAddress())
                .confirmations(confirmations)
                .timestamp(timestamp(tx))
                .build();

        return Optional.of(event);
    }

    private Value valueOf(long amount) {
        var unit = BigInteger.valueOf(amount);
        return valueOf(unit);
    }

    private Value valueOf(BigInteger unit) {
        var human = provider.converter().toHuman(unit);
        return new Value(human, unit);
    }

    private long numberOf(Block block) {
        return block.blockHeader().rawData()
                .number();
    }

    private long timestamp(Transaction tx) {
        return tx.rawData().getTimestamp();
    }

    private int confirmations(long currentBlock, long blockNumber) {
        var confirmations = (int) (blockNumber == 0 ? 0 : currentBlock - blockNumber);

        return Math.max(confirmations, 0);

    }
}
