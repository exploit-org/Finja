package org.exploit.dash;

import org.exploit.btc.BitcoinProtocolProvider;
import org.exploit.btc.address.BigBitcoinProtocolWallet;
import org.exploit.btc.address.BitcoinProtocolWallet;
import org.exploit.btc.constant.AddressType;
import org.exploit.btc.constant.FeePolicy;
import org.exploit.btc.constant.SigHash;
import org.exploit.btc.explorer.BitcoinExplorer;
import org.exploit.btc.fee.BitcoinFeeProvider;
import org.exploit.btc.generator.BitcoinAddressGenerator;
import org.exploit.btc.generator.LegacyAddressGenerator;
import org.exploit.btc.model.BitcoinMeta;
import org.exploit.btc.protocol.script.BitcoinScript;
import org.exploit.btc.protocol.script.P2PKHScript;
import org.exploit.btc.protocol.script.P2SHScript;
import org.exploit.crypto.Base58;
import org.exploit.dash.address.DashWallet;
import org.exploit.dash.constant.DashNetworkBytes;
import org.exploit.finja.core.AddressGenerator;
import org.exploit.finja.core.ValueConverter;
import org.exploit.finja.core.constant.Asset;
import org.exploit.finja.core.constant.NetworkType;
import org.exploit.finja.core.converter.MathConstantConverter;
import org.exploit.finja.core.key.ECKeyManager;
import org.exploit.finja.listener.ListenerProvider;

import java.util.List;

public class DashProvider implements BitcoinProtocolProvider {
    private final BitcoinMeta meta;
    private final BitcoinExplorer explorer;
    private final ListenerProvider<BitcoinProtocolProvider> listenerProvider;
    private final BitcoinFeeProvider feeProvider;

    private DashProvider(BitcoinMeta meta, BitcoinExplorer explorer, ListenerProvider<BitcoinProtocolProvider> listenerProvider, BitcoinFeeProvider feeProvider) {
        this.meta = meta;
        this.explorer = explorer;
        this.listenerProvider = listenerProvider;
        this.feeProvider = feeProvider;
    }

    @Override
    public BitcoinExplorer explorer() {
        return explorer;
    }

    @Override
    public BigBitcoinProtocolWallet createBigWallet(List<BitcoinProtocolWallet> wallets) {
        return new BigBitcoinProtocolWallet(this, wallets, SigHash.SIGHASH_ALL);
    }

    @Override
    public BitcoinMeta meta() {
        return meta;
    }

    @Override
    public ListenerProvider<BitcoinProtocolProvider> listenerProvider() {
        return listenerProvider;
    }

    @Override
    public BitcoinFeeProvider feeProvider() {
        return feeProvider;
    }

    @Override
    public BitcoinAddressGenerator generator(NetworkType network, AddressType type) {
        if (type == AddressType.LEGACY) {
            return switch (network) {
                case MAIN -> new LegacyAddressGenerator(asset(), DashNetworkBytes.PUBLIC_KEY_MAINNET_P2PKH);
                case TEST -> new LegacyAddressGenerator(asset(), DashNetworkBytes.PUBLIC_KEY_TESTNET_P2PKH);
            };
        }

        throw new IllegalArgumentException("Dash doesn't support " + type + " addresses");
    }

    @Override
    public DashWallet createWallet(NetworkType network, AddressType type, ECKeyManager keyManager) {
        var publicAddress = generator(network, type).encodePublicAddress(keyManager.getPublicKey());
        return createWallet(publicAddress, keyManager);
    }

    @Override
    public BitcoinScript getScript(String address) {
        if (!Base58.getInstance().isValid(address))
            throw new IllegalArgumentException("Invalid address: " + address);

        var decoded = Base58.getInstance().decode(address);
        var prefix = decoded[0];

        if (prefix == (byte) 140 || prefix == 76) {
            return new P2PKHScript();
        } else if (prefix == (byte) 19 || prefix == (byte) 16) {
            return new P2SHScript();
        } else {
            throw new IllegalArgumentException("Unknown address type: " + address);
        }
    }

    @Override
    public Asset asset() {
        return Asset.DASH;
    }

    @Override
    public DashWallet createWallet(String publicAddress, ECKeyManager keyManager) {
        return new DashWallet(this, publicAddress, keyManager);
    }

    @Override
    public AddressGenerator generator() {
        return generator(meta().network(), meta().generatorType());
    }

    @Override
    public ValueConverter converter() {
        return CONVERTER;
    }

    private static final ValueConverter CONVERTER = new MathConstantConverter(8);

    public static Builder newBuilder() {
        return new Builder();
    }

    public static class Builder {
        private BitcoinMeta meta = new BitcoinMeta(NetworkType.MAIN, AddressType.LEGACY, FeePolicy.NORMAL);

        private BitcoinExplorer explorer;
        private ListenerProvider<BitcoinProtocolProvider> listenerProvider;
        private BitcoinFeeProvider feeProvider;

        public Builder meta(BitcoinMeta meta) {
            this.meta = meta;
            return this;
        }

        public Builder explorer(BitcoinExplorer explorer) {
            this.explorer = explorer;
            return this;
        }

        public Builder listenerProvider(ListenerProvider<BitcoinProtocolProvider> listenerProvider) {
            this.listenerProvider = listenerProvider;
            return this;
        }

        public Builder feeProvider(BitcoinFeeProvider feeProvider) {
            this.feeProvider = feeProvider;
            return this;
        }

        public DashProvider build() {
            return new DashProvider(meta, explorer, listenerProvider, feeProvider);
        }
    }
}
