package org.exploit.crypto.signature;

import lombok.AllArgsConstructor;
import lombok.Data;
import org.bouncycastle.asn1.ASN1EncodableVector;
import org.bouncycastle.asn1.ASN1Integer;
import org.bouncycastle.asn1.DERSequence;
import org.bouncycastle.util.BigIntegers;
import org.exploit.crypto.curve.Secp256k1Provider;

import java.io.IOException;
import java.math.BigInteger;
import java.util.Arrays;
import java.util.Objects;

@Data
@AllArgsConstructor
public class ECDSASignature implements Signature {
    public static final int BYTES_REQUIRED = 65;
    private BigInteger r;
    private BigInteger s;
    private byte recId;

    @Override
    public byte[] encode() {
        var bytes = new byte[BYTES_REQUIRED];

        byte[] rBytes = BigIntegers.asUnsignedByteArray(32, r);
        byte[] sBytes = BigIntegers.asUnsignedByteArray(32, s);

        System.arraycopy(rBytes, 0, bytes, 0, rBytes.length);
        System.arraycopy(sBytes, 0, bytes, 32, sBytes.length);

        bytes[64] = recId;

        return bytes;
    }

    @Override
    public byte[] der() {
        try {
            var v = new ASN1EncodableVector();
            v.add(new ASN1Integer(r));
            v.add(new ASN1Integer(s));

            return new DERSequence(v).getEncoded();
        } catch (IOException e) {
            throw new IllegalStateException("Unable to encode signature to DER format", e);
        }
    }

    @Override
    public int hashCode() {
        return Objects.hash(r, s, recId);
    }

    @Override
    public boolean equals(final Object other) {
        if (!(other instanceof ECDSASignature that)) {
            return false;
        }

        return this.r.equals(that.r) && this.s.equals(that.s) && this.recId == that.recId;
    }

    public static ECDSASignature create(BigInteger r, BigInteger s, byte recId) {
        checkInBounds("r", r);
        checkInBounds("s", s);

        if (recId != 0 && recId != 1) {
            throw new IllegalArgumentException("Invalid 'recId' value, should be 0 or 1 but got " + recId);
        }

        return new ECDSASignature(r, s, recId);
    }

    public static ECDSASignature decode(byte[] bytes) {
        if (bytes.length != BYTES_REQUIRED) {
            throw new IllegalArgumentException("Invalid bytes length");
        }

        var r = new BigInteger(1, Arrays.copyOfRange(bytes, 0, 32));
        var s = new BigInteger(1, Arrays.copyOfRange(bytes, 32, 64));
        var recId = bytes[64];

        return create(r, s, recId);
    }

    private static void checkInBounds(final String name, final BigInteger i) {
        if (i.compareTo(BigInteger.ONE) < 0) {
            throw new IllegalArgumentException(
                    String.format("Invalid '%s' value, should be >= 1 but got %s", name, i));
        }

        if (i.compareTo(Secp256k1Provider.getCurveOrder()) >= 0) {
            throw new IllegalArgumentException(
                    String.format("Invalid '%s' value, should be < %s but got %s", Secp256k1Provider.getCurveOrder(), name, i));
        }
    }
}
