package org.exploit.crypto.key.secp256k1.tweak;

import org.exploit.crypto.curve.Secp256k1Provider;
import org.exploit.crypto.key.ECKeyPair;
import org.exploit.crypto.key.ECPrivateKey;
import org.exploit.crypto.key.ECPublicKey;
import org.exploit.crypto.key.secp256k1.Secp256k1KeyPair;
import org.exploit.crypto.key.secp256k1.Secp256k1PrivateKey;

import java.util.Arrays;

public class TweakedKeyPair implements ECKeyPair {
    private final TweakedPrivateKey privateKey;
    private final TweakedPublicKey publicKey;

    public TweakedKeyPair(Secp256k1PrivateKey privateKey, byte[] h) {
        this.privateKey = new TweakedPrivateKey(privateKey, h);

        var originalPublicKey = Secp256k1Provider.getInstance().getPublicKey(privateKey);
        this.publicKey = new TweakedPublicKey(originalPublicKey, h);

        var derivedPublicKey = Secp256k1Provider.getInstance().getPublicKey(this.privateKey);
        if (!Arrays.equals(this.publicKey.x(), derivedPublicKey.x())) {
            throw new IllegalStateException("Tweaked private and public keys do not match");
        }
    }

    public static TweakedKeyPair create(Secp256k1PrivateKey privateKey, byte[] h) {
        return new TweakedKeyPair(privateKey, h);
    }

    public static TweakedKeyPair create(Secp256k1KeyPair keyPair, byte[] h) {
        return new TweakedKeyPair(keyPair.privateKey(), h);
    }

    @Override
    public ECPrivateKey privateKey() {
        return privateKey;
    }

    @Override
    public ECPublicKey publicKey() {
        return publicKey;
    }

    @Override
    public void erase() {
        privateKey.erase();
    }
}