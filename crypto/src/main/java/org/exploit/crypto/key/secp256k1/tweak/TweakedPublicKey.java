package org.exploit.crypto.key.secp256k1.tweak;

import at.favre.lib.bytes.Bytes;
import lombok.Getter;
import org.exploit.crypto.Hash;
import org.exploit.crypto.curve.Secp256k1Provider;
import org.exploit.crypto.key.secp256k1.Secp256k1PublicKey;
import org.exploit.gmp.BigInt;
import org.exploit.secp256k1.Secp256k1;
import org.exploit.secp256k1.Secp256k1PointOps;

import static org.exploit.crypto.utils.Schnorr.liftX;

import lombok.Getter;
import org.exploit.secp256k1.XOnlyPublicKey;
import org.exploit.secp256k1.jna.LibSecp256k1;
import org.exploit.secp256k1.jna.Secp256k1Context;
import org.exploit.secp256k1.jna.struct.Secp256k1Pub;
import org.exploit.secp256k1.jna.struct.Secp256k1XOnlyPub;

import java.util.Arrays;
import java.math.BigInteger;

@Getter
public class TweakedPublicKey extends Secp256k1PublicKey {
    private final Secp256k1PublicKey originalPublicKey;
    private final int parity;
    private final byte[] h;

    public TweakedPublicKey(Secp256k1PublicKey publicKey, byte[] h) {
        this(publicKey, h, taprootTweakXOnlyPub(publicKey.x(), h));
    }


    private TweakedPublicKey(Secp256k1PublicKey publicKey, byte[] h, XOnlyPublicKey tweaked) {
        super(tweaked.getBytes());
        this.originalPublicKey = publicKey;
        this.h = h;
        this.parity = tweaked.getParity();
    }

    private static XOnlyPublicKey taprootTweakXOnlyPub(byte[] internalXonly32, byte[] merkleRoot32) {
        var tweak32 = Secp256k1.tapTweak32(internalXonly32, merkleRoot32);

        var internal = new Secp256k1XOnlyPub();
        if (LibSecp256k1.INSTANCE.secp256k1_xonly_pubkey_parse(Secp256k1Context.CTX, internal, internalXonly32) != 1) {
            throw new IllegalArgumentException("Invalid internal x-only pubkey");
        }

        var tweakedFull = new Secp256k1Pub();
        if (LibSecp256k1.INSTANCE.secp256k1_xonly_pubkey_tweak_add(Secp256k1Context.CTX, tweakedFull, internal, tweak32) != 1) {
            throw new IllegalStateException("TapTweak add failed");
        }

        var tweakedXonly = new Secp256k1XOnlyPub();
        var parityArr = new int[1];
        if (LibSecp256k1.INSTANCE.secp256k1_xonly_pubkey_from_pubkey(Secp256k1Context.CTX, tweakedXonly, parityArr, tweakedFull) != 1) {
            throw new IllegalStateException("Failed to convert tweaked full pubkey to x-only");
        }

        var outXonly = new byte[32];
        if (LibSecp256k1.INSTANCE.secp256k1_xonly_pubkey_serialize(Secp256k1Context.CTX, outXonly, tweakedXonly) != 1) {
            throw new IllegalStateException("Failed to serialize tweaked x-only pubkey");
        }

        return new XOnlyPublicKey(outXonly, parityArr[0]);
    }

    @Override
    public byte[] encoded() {
        return encoded;
    }

    @Override
    public byte[] x() {
        return encoded;
    }

    @Override
    public Secp256k1PointOps point() {
        return liftX(new BigInt(1, encoded()));
    }
}