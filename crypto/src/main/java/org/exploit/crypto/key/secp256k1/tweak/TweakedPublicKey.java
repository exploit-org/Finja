package org.exploit.crypto.key.secp256k1.tweak;

import at.favre.lib.bytes.Bytes;
import lombok.Getter;
import org.bouncycastle.math.ec.ECPoint;
import org.bouncycastle.util.BigIntegers;
import org.exploit.crypto.Hash;
import org.exploit.crypto.curve.Secp256k1Provider;
import org.exploit.crypto.key.secp256k1.Secp256k1PublicKey;

import java.math.BigInteger;

import static org.exploit.crypto.utils.Schnorr.liftX;

@Getter
public class TweakedPublicKey extends Secp256k1PublicKey {
    private final Secp256k1PublicKey originalPublicKey;
    private final int parity;
    private final byte[] h;

    public TweakedPublicKey(Secp256k1PublicKey publicKey, byte[] h) {
        super(taprootTweakPubkey(publicKey, h));
        this.originalPublicKey = publicKey;
        this.h = h;
        this.parity = computeParity(publicKey, h);
    }

    private static byte[] taprootTweakPubkey(Secp256k1PublicKey pubkey, byte[] h) {
        var pubkeyBytes = pubkey.x();
        var n = Secp256k1Provider.getCurveOrder();

        var tweakInput = Bytes.from(pubkeyBytes, h).array();
        var tHash = Hash.taggedHash(tweakInput, "TapTweak");
        var t = new BigInteger(1, tHash).mod(n);
        if (t.compareTo(n) >= 0) {
            throw new IllegalArgumentException("t >= SECP256K1_ORDER");
        }

        var P = liftX(new BigInteger(1, pubkeyBytes));
        if (P == null) {
            throw new IllegalArgumentException("Invalid public key, point not on curve");
        }

        var G = Secp256k1Provider.CURVE.getG();
        var Q = P.add(G.multiply(t)).normalize();

        return BigIntegers.asUnsignedByteArray(32, Q.getAffineXCoord().toBigInteger());
    }

    @Override
    public byte[] encoded() {
        return encoded; // X coord
    }

    @Override
    public byte[] x() {
        return encoded;
    }

    @Override
    public ECPoint point() {
        return liftX(new BigInteger(1, encoded()));
    }

    private static int computeParity(Secp256k1PublicKey pubkey, byte[] h) {
        var pubkeyBytes = pubkey.x();
        var n = Secp256k1Provider.getCurveOrder();

        var tweakInput = Bytes.from(pubkeyBytes, h).array();
        var tHash = Hash.taggedHash(tweakInput, "TapTweak");
        var t = new BigInteger(1, tHash).mod(n);

        var P = liftX(new BigInteger(1, pubkeyBytes));
        if (P == null) {
            throw new IllegalArgumentException("Invalid public key, point not on curve");
        }

        var G = Secp256k1Provider.CURVE.getG();

        var Q = P.add(G.multiply(t)).normalize();

        return Q.getAffineYCoord().toBigInteger().testBit(0) ? 1 : 0;
    }
}