package org.exploit.crypto.key.secp256k1.tweak;

import at.favre.lib.bytes.Bytes;
import lombok.Getter;
import org.bouncycastle.util.Arrays;
import org.exploit.crypto.Hash;
import org.exploit.crypto.curve.Secp256k1Provider;
import org.exploit.crypto.key.secp256k1.Secp256k1PrivateKey;
import org.exploit.gmp.BigInt;
import org.exploit.sodium.ReadOnlyBuffer;

@Getter
public class TweakedPrivateKey extends Secp256k1PrivateKey {
    private final Secp256k1PrivateKey originalPrivateKey;
    private final byte[] h;

    public TweakedPrivateKey(Secp256k1PrivateKey privateKey, byte[] h) {
        super(taprootTweakSeckey(privateKey, h));

        this.originalPrivateKey = privateKey;
        this.h = h;
    }

    private static ReadOnlyBuffer taprootTweakSeckey(Secp256k1PrivateKey seckey0, byte[] h) {
        var seckey0Int = seckey0.toBigInt();

        var G = Secp256k1Provider.CURVE.getG();
        var n = Secp256k1Provider.getCurveOrder();

        var P = G.mul(seckey0Int).normalize();

        var hasEvenY = !P.getAffineY().testBit(0);
        var seckey = hasEvenY ? seckey0Int : n.subtract(seckey0Int);

        var xP = P.getAffineX().toUnsignedByteArray(32);
        var tweakInput = Bytes.from(xP, h).array();
        var tHash = Hash.taggedHash(tweakInput, "TapTweak");
        var t = new BigInt(1, tHash).mod(n);
        if (t.compareTo(n) >= 0) {
            throw new IllegalArgumentException("t >= SECP256K1_ORDER");
        }

        var tweakedSeckeyInt = seckey.add(t).mod(n);
        var tweakedSeckeyBytes = tweakedSeckeyInt.toUnsignedByteArray(32);

        var buffer = new ReadOnlyBuffer(tweakedSeckeyBytes);
        Arrays.fill(tweakedSeckeyBytes, (byte) 0);

        return buffer;
    }
}