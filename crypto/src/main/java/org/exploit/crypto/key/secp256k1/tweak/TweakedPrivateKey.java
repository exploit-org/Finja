package org.exploit.crypto.key.secp256k1.tweak;

import at.favre.lib.bytes.Bytes;
import lombok.Getter;
import org.bouncycastle.util.BigIntegers;
import org.exploit.crypto.Hash;
import org.exploit.crypto.curve.Secp256k1Provider;
import org.exploit.crypto.key.secp256k1.Secp256k1PrivateKey;
import org.exploit.crypto.utils.SensitiveBytes;
import org.owasp.netryx.memory.SecureMemory;

import java.math.BigInteger;

@Getter
public class TweakedPrivateKey extends Secp256k1PrivateKey {
    private final Secp256k1PrivateKey originalPrivateKey;
    private final byte[] h;

    public TweakedPrivateKey(Secp256k1PrivateKey privateKey, byte[] h) {
        super(taprootTweakSeckey(privateKey, h));

        this.originalPrivateKey = privateKey;
        this.h = h;
    }

    private static SecureMemory taprootTweakSeckey(Secp256k1PrivateKey seckey0, byte[] h) {
        var seckey0Int = seckey0.toBigInt();

        var G = Secp256k1Provider.CURVE.getG();
        var n = Secp256k1Provider.getCurveOrder();

        var P = G.multiply(seckey0Int).normalize();

        var hasEvenY = !P.getAffineYCoord().toBigInteger().testBit(0);
        var seckey = hasEvenY ? seckey0Int : n.subtract(seckey0Int);

        var xP = BigIntegers.asUnsignedByteArray(32, P.getAffineXCoord().toBigInteger());
        var tweakInput = Bytes.from(xP, h).array();
        var tHash = Hash.taggedHash(tweakInput, "TapTweak");
        var t = new BigInteger(1, tHash).mod(n);
        if (t.compareTo(n) >= 0) {
            throw new IllegalArgumentException("t >= SECP256K1_ORDER");
        }

        var tweakedSeckeyInt = seckey.add(t).mod(n);
        var tweakedSeckeyBytes = BigIntegers.asUnsignedByteArray(32, tweakedSeckeyInt);

        return SensitiveBytes.write(tweakedSeckeyBytes);
    }
}