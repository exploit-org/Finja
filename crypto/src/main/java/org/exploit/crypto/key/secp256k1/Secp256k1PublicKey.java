package org.exploit.crypto.key.secp256k1;

import org.bouncycastle.util.BigIntegers;
import org.bouncycastle.util.encoders.Hex;
import org.exploit.crypto.curve.Secp256k1Provider;
import org.exploit.crypto.key.ECPublicKey;
import org.exploit.crypto.key.secp256k1.tweak.TweakedPublicKey;
import org.exploit.secp256k1.Secp256k1PointOps;

import java.math.BigInteger;
import java.util.Arrays;

public class Secp256k1PublicKey implements ECPublicKey<Secp256k1PointOps> {
    protected final byte[] encoded;

    public Secp256k1PublicKey(byte[] encoded) {
        this.encoded = encoded;
    }

    @Override
    public byte[] compress() {
        if (encoded.length == 33) {
            return encoded;
        }

        var ecPoint = point();

        var xBytes = ecPoint.getAffineX().toUnsignedByteArray(32);
        var yCoord = ecPoint.getAffineY();

        var result = new byte[33];

        System.arraycopy(xBytes, 0, result, 33 - xBytes.length, xBytes.length);

        result[0] = (byte) (yCoord.testBit(0) ? 0x03 : 0x02);

        return result;
    }

    public TweakedPublicKey tweak(byte[] h) {
        return new TweakedPublicKey(this, h);
    }

    @Override
    public byte[] encoded() {
        if (encoded.length == 33) {
            return point().encode(false);
        }

        return encoded;
    }

    public byte[] x() {
        return point().normalize().getAffineX().toUnsignedByteArray(32);
    }

    @Override
    public Secp256k1PointOps point() {
        return Secp256k1Provider.CURVE.decodePoint(encoded);
    }

    @Override
    public Class<Secp256k1PointOps> pointOpsClass() {
        return Secp256k1PointOps.class;
    }

    @Override
    public BigInteger toBigInt() {
        return new BigInteger(1, encoded);
    }

    @Override
    public String hex() {
        return Hex.toHexString(encoded());
    }

    @Override
    public void erase() {
        Arrays.fill(encoded, (byte) 0);
    }

    @Override
    public byte[] prepareNonHardenedData(int childIndex) {
        var parentPublicKey = compress();
        var data = new byte[parentPublicKey.length + 4];
        System.arraycopy(parentPublicKey, 0, data, 0, parentPublicKey.length);

        data[data.length - 4] = (byte) ((childIndex >> 24) & 0xFF);
        data[data.length - 3] = (byte) ((childIndex >> 16) & 0xFF);
        data[data.length - 2] = (byte) ((childIndex >> 8) & 0xFF);
        data[data.length - 1] = (byte) (childIndex & 0xFF);

        return data;
    }

    public static Secp256k1PublicKey create(BigInteger key) {
        return create(BigIntegers.asUnsignedByteArray(65, key));
    }

    public static Secp256k1PublicKey create(byte[] encoded) {
        return new Secp256k1PublicKey(encoded);
    }

    public static Secp256k1PublicKey fromCompressed(byte[] compressed) {
        if (compressed == null || compressed.length != 33) {
            throw new IllegalArgumentException("Invalid compressed public key length");
        }

        if (compressed[0] != 0x02 && compressed[0] != 0x03) {
            throw new IllegalArgumentException("Invalid compressed public key format");
        }

        var point = Secp256k1Provider.CURVE.decodePoint(compressed);
        return new Secp256k1PublicKey(point.encode(false));
    }

}