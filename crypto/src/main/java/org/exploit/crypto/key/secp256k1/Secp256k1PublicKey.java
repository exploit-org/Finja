package org.exploit.crypto.key.secp256k1;

import at.favre.lib.bytes.Bytes;
import org.bouncycastle.math.ec.ECPoint;
import org.bouncycastle.util.BigIntegers;
import org.bouncycastle.util.encoders.Hex;
import org.exploit.crypto.curve.Secp256k1Provider;
import org.exploit.crypto.key.ECPublicKey;
import org.exploit.crypto.key.secp256k1.tweak.TweakedPublicKey;

import java.math.BigInteger;
import java.util.Arrays;

public class Secp256k1PublicKey implements ECPublicKey {
    protected final byte[] encoded;

    public Secp256k1PublicKey(byte[] encoded) {
        this.encoded = encoded;
    }

    @Override
    public byte[] compress() {
        var ecPoint = point();

        var xBytes = BigIntegers.asUnsignedByteArray(32, ecPoint.getXCoord().toBigInteger());
        var yCoord = ecPoint.getYCoord().toBigInteger();

        var result = new byte[33];

        System.arraycopy(xBytes, 0, result, 33 - xBytes.length, xBytes.length);

        result[0] = (byte) (yCoord.testBit(0) ? 0x03 : 0x02);

        return result;
    }

    public TweakedPublicKey tweak(byte[] h) {
        return new TweakedPublicKey(this, h);
    }

    @Override
    public byte[] encoded() {
        if (encoded[0] != (byte) 0x04)
            return Bytes.from((byte) 0x04).append(encoded).array();

        return encoded;
    }

    @Override
    public ECPoint point() {
        return Secp256k1Provider.CURVE.getCurve().decodePoint(encoded());
    }

    @Override
    public BigInteger toBigInt() {
        return new BigInteger(1, encoded);
    }

    @Override
    public String hex() {
        return Hex.toHexString(encoded);
    }

    @Override
    public void erase() {
        Arrays.fill(encoded, (byte) 0);
    }

    @Override
    public byte[] prepareNonHardenedData(int childIndex) {
        var parentPublicKey = compress();
        var data = new byte[parentPublicKey.length + 4];
        System.arraycopy(parentPublicKey, 0, data, 0, parentPublicKey.length);

        data[data.length - 4] = (byte) ((childIndex >> 24) & 0xFF);
        data[data.length - 3] = (byte) ((childIndex >> 16) & 0xFF);
        data[data.length - 2] = (byte) ((childIndex >> 8) & 0xFF);
        data[data.length - 1] = (byte) (childIndex & 0xFF);

        return data;
    }

    public static Secp256k1PublicKey create(BigInteger key) {
        return create(BigIntegers.asUnsignedByteArray(64, key));
    }

    public static Secp256k1PublicKey create(byte[] encoded) {
        return new Secp256k1PublicKey(encoded);
    }

    public static Secp256k1PublicKey fromCompressed(byte[] compressed) {
        if (compressed.length != 33) {
            throw new IllegalArgumentException("Invalid compressed public key length");
        }

        var xBytes = Arrays.copyOfRange(compressed, 1, 33);
        var x = new BigInteger(1, xBytes);

        var isYEven = (compressed[0] & 0x01) == 0;

        var curve = Secp256k1Provider.CURVE.getCurve();

        var alpha = curve.createPoint(x, BigInteger.ZERO).getXCoord().toBigInteger();
        var beta = alpha.multiply(x).mod(curve.getOrder())
                .add(curve.getA().toBigInteger().multiply(x))
                .add(curve.getB().toBigInteger())
                .mod(curve.getOrder());

        var y = beta.modPow(curve.getField().getCharacteristic().add(BigInteger.ONE).shiftRight(2), curve.getField().getCharacteristic());

        if (y.testBit(0) != isYEven) {
            y = curve.getField().getCharacteristic().subtract(y);
        }

        var ecPoint = curve.createPoint(x, y);
        return new Secp256k1PublicKey(ecPoint.getEncoded(false));
    }
}