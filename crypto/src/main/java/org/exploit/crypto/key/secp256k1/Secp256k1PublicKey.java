package org.exploit.crypto.key.secp256k1;

import at.favre.lib.bytes.Bytes;
import org.bouncycastle.math.ec.ECPoint;
import org.bouncycastle.util.BigIntegers;
import org.bouncycastle.util.encoders.Hex;
import org.exploit.crypto.curve.Secp256k1Provider;
import org.exploit.crypto.key.ECPublicKey;
import org.exploit.crypto.key.secp256k1.tweak.TweakedPublicKey;

import java.math.BigInteger;
import java.util.Arrays;

public class Secp256k1PublicKey implements ECPublicKey {
    protected final byte[] encoded;

    public Secp256k1PublicKey(byte[] encoded) {
        this.encoded = encoded;
    }

    @Override
    public byte[] compress() {
        var ecPoint = point();

        var xBytes = BigIntegers.asUnsignedByteArray(32, ecPoint.getXCoord().toBigInteger());
        var yCoord = ecPoint.getYCoord().toBigInteger();

        var result = new byte[33];

        System.arraycopy(xBytes, 0, result, 33 - xBytes.length, xBytes.length);

        result[0] = (byte) (yCoord.testBit(0) ? 0x03 : 0x02);

        return result;
    }

    public TweakedPublicKey tweak(byte[] h) {
        return new TweakedPublicKey(this, h);
    }

    @Override
    public byte[] encoded() {
        if (encoded[0] != (byte) 0x04)
            return Bytes.from((byte) 0x04).append(encoded).array();

        return encoded;
    }

    @Override
    public ECPoint point() {
        return Secp256k1Provider.CURVE.getCurve().decodePoint(encoded());
    }

    @Override
    public BigInteger toBigInt() {
        return new BigInteger(1, encoded);
    }

    @Override
    public String hex() {
        return Hex.toHexString(encoded);
    }

    @Override
    public void erase() {
        Arrays.fill(encoded, (byte) 0);
    }

    @Override
    public byte[] prepareNonHardenedData(int childIndex) {
        var parentPublicKey = compress();
        var data = new byte[parentPublicKey.length + 4];
        System.arraycopy(parentPublicKey, 0, data, 0, parentPublicKey.length);

        data[data.length - 4] = (byte) ((childIndex >> 24) & 0xFF);
        data[data.length - 3] = (byte) ((childIndex >> 16) & 0xFF);
        data[data.length - 2] = (byte) ((childIndex >> 8) & 0xFF);
        data[data.length - 1] = (byte) (childIndex & 0xFF);

        return data;
    }

    public static Secp256k1PublicKey create(BigInteger key) {
        return create(BigIntegers.asUnsignedByteArray(64, key));
    }

    public static Secp256k1PublicKey create(byte[] encoded) {
        return new Secp256k1PublicKey(encoded);
    }

    public static Secp256k1PublicKey fromCompressed(byte[] compressed) {
        if (compressed == null || compressed.length != 33) {
            throw new IllegalArgumentException("Invalid compressed public key length");
        }

        if (compressed[0] != 0x02 && compressed[0] != 0x03) {
            throw new IllegalArgumentException("Invalid compressed public key format");
        }

        var point = getEcPoint(compressed);
        return new Secp256k1PublicKey(point.getEncoded(false));
    }

    private static ECPoint getEcPoint(byte[] compressed) {
        var xBytes = Arrays.copyOfRange(compressed, 1, 33);
        var x = new BigInteger(1, xBytes);

        var curve = Secp256k1Provider.CURVE.getCurve();
        var p = curve.getField().getCharacteristic();

        var ySquared = x.pow(3).add(BigInteger.valueOf(7)).mod(p);

        var y = ySquared.modPow(p.add(BigInteger.ONE).shiftRight(2), p);

        if ((compressed[0] == 0x02 && y.testBit(0)) || (compressed[0] == 0x03 && !y.testBit(0))) {
            y = p.subtract(y);
        }

        return curve.createPoint(x, y);
    }
}