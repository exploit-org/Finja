package org.exploit.crypto.key.ed25519;

import org.bouncycastle.util.encoders.Hex;
import org.exploit.crypto.curve.Ed25519Provider;
import org.exploit.crypto.key.ECPublicKey;
import org.exploit.ed25519.Ed25519PointOps;

import java.math.BigInteger;
import java.util.Arrays;

public class Ed25519PublicKey implements ECPublicKey<Ed25519PointOps> {
    private final byte[] publicKey;

    public Ed25519PublicKey(byte[] publicKey) {
        this.publicKey = publicKey;
    }

    @Override
    public byte[] compress() {
        return publicKey;
    }

    @Override
    public byte[] encoded() {
        return publicKey;
    }

    @Override
    public Ed25519PointOps point() {
        return Ed25519Provider.CURVE.decodePoint(publicKey);
    }

    @Override
    public Class<Ed25519PointOps> pointOpsClass() {
        return Ed25519PointOps.class;
    }

    @Override
    public BigInteger toBigInt() {
        return new BigInteger(1, publicKey);
    }

    @Override
    public String hex() {
        return Hex.toHexString(publicKey);
    }

    @Override
    public void erase() {
        Arrays.fill(publicKey, (byte) 0);
    }

    @Override
    public byte[] prepareNonHardenedData(int childIndex) {
        throw new UnsupportedOperationException("Ed25519 uses only hardened derivation");
    }

    public static Ed25519PublicKey create(byte[] key) {
        return new Ed25519PublicKey(key);
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        Ed25519PublicKey that = (Ed25519PublicKey) obj;
        return Arrays.equals(publicKey, that.publicKey);
    }

    @Override
    public int hashCode() {
        return Arrays.hashCode(publicKey);
    }
}