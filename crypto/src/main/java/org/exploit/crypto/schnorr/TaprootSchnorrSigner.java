package org.exploit.crypto.schnorr;

import org.exploit.crypto.key.secp256k1.Secp256k1PrivateKey;
import org.exploit.crypto.key.secp256k1.Secp256k1PublicKey;
import org.exploit.secp256k1.Secp256k1;
import org.exploit.tss.signature.SchnorrSignature;

import java.security.SecureRandom;
import java.util.Arrays;

public final class TaprootSchnorrSigner {
    private static final SecureRandom RNG = new SecureRandom();
    private static final byte[] EMPTY_MERKLE_ROOT = new byte[0];

    public SchnorrSignature sign(Secp256k1PrivateKey sk, byte[] msg32) {
        require32(msg32, "message");

        var aux32 = new byte[32];
        RNG.nextBytes(aux32);

        return sk.encoded().read(encoded -> {
            var sig64 = Secp256k1.taprootSign(msg32, encoded, EMPTY_MERKLE_ROOT, aux32);
            return toSignature(sig64);
        });
    }

    public boolean verify(Secp256k1PublicKey pk, byte[] msg32, SchnorrSignature sig) {
        require32(msg32, "message");
        return Secp256k1.taprootVerify(msg32, sig.encode(), pk.x(), EMPTY_MERKLE_ROOT);
    }

    private static SchnorrSignature toSignature(byte[] sig64) {
        var r = Arrays.copyOfRange(sig64, 0, 32);
        var s = Arrays.copyOfRange(sig64, 32, 64);
        return new SchnorrSignature(r, s);
    }

    private static void require32(byte[] a, String field) {
        if (a == null || a.length != 32)
            throw new IllegalArgumentException("Invalid " + field + " length: expected 32, got " + (a == null ? "null" : a.length));
    }
}