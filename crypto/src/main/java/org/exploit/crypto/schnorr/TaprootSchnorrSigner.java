package org.exploit.crypto.schnorr;

import at.favre.lib.bytes.Bytes;
import org.bouncycastle.math.ec.custom.sec.SecP256K1Curve;
import org.bouncycastle.util.BigIntegers;
import org.exploit.crypto.Hash;
import org.exploit.crypto.curve.Secp256k1Provider;
import org.exploit.crypto.key.secp256k1.Secp256k1PrivateKey;
import org.exploit.crypto.key.secp256k1.Secp256k1PublicKey;
import org.exploit.crypto.key.secp256k1.tweak.TweakedKeyPair;
import org.exploit.crypto.signature.SchnorrSignature;

import java.math.BigInteger;
import java.security.SecureRandom;

import static org.exploit.crypto.utils.Schnorr.liftX;

public class TaprootSchnorrSigner {
    private static final SecureRandom RANDOM = new SecureRandom();

    public SchnorrSignature sign(Secp256k1PrivateKey privateKey, byte[] message) {
        if (message.length != 32)
            throw new IllegalArgumentException("Invalid message length. Expected 32, got: " + message.length);

        var keyPair = new TweakedKeyPair(privateKey, new byte[0]);
        var tweakedKey = keyPair.privateKey();
        var publicKey = keyPair.publicKey();

        var aux = new byte[32];
        RANDOM.nextBytes(aux);

        var d = tweakedKey.toBigInt();
        var n = Secp256k1Provider.getCurveOrder();

        if (d.equals(BigInteger.ZERO) || d.compareTo(n) >= 0) {
            throw new IllegalArgumentException("Invalid secret key");
        }

        // P = d * G
        var P = publicKey.point();
        var hasEvenY = !P.getAffineYCoord().toBigInteger().testBit(0);

        if (!hasEvenY)
            d = n.subtract(d);

        var dBytes = BigIntegers.asUnsignedByteArray(32, d);
        var taggedAuxHash = Hash.taggedHash(aux, "BIP0340/aux");
        var t = xorBytes(dBytes, taggedAuxHash);

        // (t || bytes(P.x) || m)
        var xBytes = BigIntegers.asUnsignedByteArray(32, P.getAffineXCoord().toBigInteger());
        var nonceInput = Bytes.from(t, xBytes, message).array();
        var rand = Hash.taggedHash(nonceInput, "BIP0340/nonce");

        var k = new BigInteger(1, rand).mod(n);
        if (k.equals(BigInteger.ZERO)) {
            throw new IllegalArgumentException("Nonce generation failed");
        }

        var R = Secp256k1Provider.getInstance().getPublicKey(Secp256k1PrivateKey.create(k)).point();
        var isREven = !R.getAffineYCoord().toBigInteger().testBit(0);
        if (!isREven) {
            k = n.subtract(k);
        }

        // e = Hash(tagged("BIP0340/challenge") || R.x || P.x || message)
        var rBytes = BigIntegers.asUnsignedByteArray(32, R.getAffineXCoord().toBigInteger());
        var eHashInput = Bytes.from(rBytes, xBytes, message).array();
        var eBytes = Hash.taggedHash(eHashInput, "BIP0340/challenge");
        var e = new BigInteger(1, eBytes).mod(n);

        // s = k + e * d (mod n)
        var s = k.add(e.multiply(d)).mod(n);
        return new SchnorrSignature(rBytes, BigIntegers.asUnsignedByteArray(32, s));
    }

    public boolean verify(Secp256k1PublicKey pk, byte[] message, SchnorrSignature signature) {
        var p = SecP256K1Curve.q;
        var n = Secp256k1Provider.getCurveOrder();

        var x = new BigInteger(1, pk.x());
        if (x.compareTo(p) >= 0) {
            return false;
        }

        // P = lift_x(int(pk))
        var P = liftX(x);
        if (P == null) return false;

        var rBytes = signature.getR();
        var sBytes = signature.getS();

        var r = new BigInteger(1, rBytes);
        var s = new BigInteger(1, sBytes);

        // if r ≥ p or s ≥ n -> fail
        if (r.compareTo(p) >= 0 || s.compareTo(n) >= 0) return false;

        // Se = int(hashBIP0340/challenge(bytes(r) || bytes(P.x) || m)) mod n
        var xBytes = BigIntegers.asUnsignedByteArray(32, x);
        var eHashInput = Bytes.from(rBytes, xBytes, message).array();
        var eBytes = Hash.taggedHash(eHashInput, "BIP0340/challenge");
        var e = new BigInteger(1, eBytes).mod(n);

        // R = s⋅G - e⋅P
        var G = Secp256k1Provider.CURVE.getG();
        var R = G.multiply(s).subtract(P.multiply(e)).normalize();

        if (R.isInfinity()) return false;

        if (R.getAffineYCoord().toBigInteger().testBit(0)) return false;

        return R.getAffineXCoord().toBigInteger().equals(r);
    }

    private static byte[] xorBytes(byte[] a, byte[] b) {
        var result = new byte[a.length];
        for (var i = 0; i < a.length; i++) {
            result[i] = (byte) (a[i] ^ b[i]);
        }
        return result;
    }
}
