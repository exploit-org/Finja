package org.exploit.crypto;

import org.exploit.crypto.utils.Require;

import java.util.Arrays;
import java.util.Locale;

public class Bech32 {
    private static final String CHARSET = "qpzry9x8gf2tvdw0s3jn54khce6mua7l";

    private static final byte[] CHARSET_REV = {
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            15, -1, 10, 17, 21, 20, 26, 30, 7, 5, -1, -1, -1, -1, -1, -1,
            -1, 29, -1, 24, 13, 25, 9, 8, 23, -1, 18, 22, 31, 27, 19, -1,
            1, 0, 3, 16, 11, 28, 12, 14, 6, 4, 2, -1, -1, -1, -1, -1,
            -1, 29, -1, 24, 13, 25, 9, 8, 23, -1, 18, 22, 31, 27, 19, -1,
            1, 0, 3, 16, 11, 28, 12, 14, 6, 4, 2, -1, -1, -1, -1, -1
    };

    private static final int BECH32_CONST = 1;
    private static final int BECH32M_CONST = 0x2bc830a3;

    public enum Encoding {BECH32, BECH32M}

    private static int polymod(byte[] values) {
        var c = 1;

        for (var v : values) {
            var c0 = (c >>> 25) & 0xff;
            c = ((c & 0x1ffffff) << 5) ^ (v & 0xff);

            if ((c0 & 1) != 0) c ^= 0x3b6a57b2;
            if ((c0 & 2) != 0) c ^= 0x26508e6d;
            if ((c0 & 4) != 0) c ^= 0x1ea119fa;
            if ((c0 & 8) != 0) c ^= 0x3d4233dd;
            if ((c0 & 16) != 0) c ^= 0x2a1462b3;
        }
        return c;
    }

    private static byte[] expandHrp(final String hrp) {
        var hrpLength = hrp.length();

        var ret = new byte[hrpLength * 2 + 1];

        for (var i = 0; i < hrpLength; ++i) {
            var c = hrp.charAt(i) & 0x7f;

            ret[i] = (byte) ((c >>> 5) & 0x07);
            ret[i + hrpLength + 1] = (byte) (c & 0x1f);
        }

        ret[hrpLength] = 0;
        return ret;
    }

    private static Encoding verifyChecksum(String hrp, byte[] values) {
        var hrpExpanded = expandHrp(hrp);
        var combined = new byte[hrpExpanded.length + values.length];

        System.arraycopy(hrpExpanded, 0, combined, 0, hrpExpanded.length);
        System.arraycopy(values, 0, combined, hrpExpanded.length, values.length);

        var check = polymod(combined);

        if (check == BECH32_CONST)
            return Encoding.BECH32;
        else if (check == BECH32M_CONST)
            return Encoding.BECH32M;
        else
            return null;
    }

    private static byte[] createChecksum(Encoding encoding, final String hrp, final byte[] values) {
        var hrpExpanded = expandHrp(hrp);
        var enc = new byte[hrpExpanded.length + values.length + 6];

        System.arraycopy(hrpExpanded, 0, enc, 0, hrpExpanded.length);
        System.arraycopy(values, 0, enc, hrpExpanded.length, values.length);

        var mod = polymod(enc) ^ (encoding == Encoding.BECH32 ? BECH32_CONST : BECH32M_CONST);
        var ret = new byte[6];

        for (var i = 0; i < 6; ++i)
            ret[i] = (byte) ((mod >>> (5 * (5 - i))) & 31);

        return ret;
    }

    public static String encode(Bech32Data bech32) {
        return encode(bech32.encoding, bech32.hrp, bech32.data);
    }

    public static String encode(Encoding encoding, String hrp, byte[] values) {
        var lcHrp = hrp.toLowerCase(Locale.ROOT);
        var checksum = createChecksum(encoding, lcHrp, values);
        var combined = new byte[values.length + checksum.length];

        System.arraycopy(values, 0, combined, 0, values.length);
        System.arraycopy(checksum, 0, combined, values.length, checksum.length);

        var sb = new StringBuilder(lcHrp.length() + 1 + combined.length);

        sb.append(lcHrp);
        sb.append('1');

        for (var b : combined)
            sb.append(CHARSET.charAt(b));

        return sb.toString();
    }

    public static Bech32Data decode(final String str) {
        boolean lower = false, upper = false;

        Require.isTrue(str.length() >= 8 && str.length() <= 90, () -> "Input size should be in 8..90");

        for (var i = 0; i < str.length(); ++i) {
            var c = str.charAt(i);

            Require.isTrue(c >= 33 && c <= 126, () -> "Invalid char: " + c);

            if (c >= 'a' && c <= 'z') {
                Require.isTrue(!upper, () -> "Invalid char: " + c);
                lower = true;
            }

            if (c >= 'A' && c <= 'Z') {
                Require.isTrue(!lower, () -> "Invalid char: " + c);
                upper = true;
            }
        }

        var pos = str.lastIndexOf('1');
        Require.isTrue(pos >= 1, () -> "Missing human-readable part");

        var dataPartLength = str.length() - 1 - pos;
        Require.isTrue(dataPartLength >= 6, () -> "Data part too short: " + dataPartLength);

        var values = new byte[dataPartLength];

        for (var i = 0; i < dataPartLength; ++i) {
            var c = str.charAt(i + pos + 1);
            Require.isTrue(CHARSET_REV[c] != -1, () -> "Invalid char: " + c);

            values[i] = CHARSET_REV[c];
        }

        var hrp = str.substring(0, pos).toLowerCase(Locale.ROOT);
        var encoding = verifyChecksum(hrp, values);

        Require.isTrue(encoding != null, () -> "Invalid checksum");

        return new Bech32Data(encoding, hrp, Arrays.copyOfRange(values, 0, values.length - 6));
    }

    public record Bech32Data(Encoding encoding, String hrp, byte[] data) {}
}