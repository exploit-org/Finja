package org.exploit.crypto.utils;

import org.bouncycastle.math.ec.ECPoint;
import org.bouncycastle.math.ec.custom.sec.SecP256K1Curve;
import org.exploit.crypto.curve.Secp256k1Provider;

import java.math.BigInteger;

public final class Schnorr {
    private Schnorr() {}

    public static ECPoint liftX(BigInteger x) {
        var p = SecP256K1Curve.q;
        if (x.compareTo(BigInteger.ZERO) < 0 || x.compareTo(p) >= 0)
            return null;

        // y^2 = x^3 + 7 mod p
        var alpha = x.modPow(BigInteger.valueOf(3), p).add(BigInteger.valueOf(7)).mod(p);

        // y = sqrt(alpha) mod p
        var beta = sqrtModP(alpha, p);
        if (beta == null)
            return null;

        var y = beta.testBit(0) ? p.subtract(beta) : beta;

        return Secp256k1Provider.CURVE.getCurve().createPoint(x, y);
    }

    public static BigInteger sqrtModP(BigInteger a, BigInteger p) {
        if (!p.testBit(0) || !p.testBit(1))
            throw new IllegalArgumentException("p must be congruent to 3 mod 4 (secp256k1)");

        // sqrt(a) â‰¡ a^{(p + 1) / 4} mod p
        var exp = p.add(BigInteger.ONE).shiftRight(2);
        var sqrt = a.modPow(exp, p);

        if (sqrt.multiply(sqrt).mod(p).compareTo(a.mod(p)) != 0) {
            return null;
        }

        return sqrt;
    }
}
