package org.exploit.crypto.curve;

import org.exploit.crypto.constant.SupportedCurve;
import org.exploit.crypto.key.ECKeyPair;
import org.exploit.crypto.key.ECPrivateKey;
import org.exploit.crypto.key.ECPublicKey;
import org.exploit.crypto.key.ed25519.Ed25519KeyPair;
import org.exploit.crypto.key.ed25519.Ed25519PrivateKey;
import org.exploit.crypto.key.ed25519.Ed25519PublicKey;
import org.exploit.crypto.schnorr.TaprootSchnorrSigner;
import org.exploit.ed25519.Ed25519;
import org.exploit.ed25519.Ed25519CurveParams;
import org.exploit.ed25519.Ed25519PointOps;
import org.exploit.tss.signature.SchnorrSignature;
import org.exploit.tss.signature.Signature;

import java.util.Arrays;

public class Ed25519Provider implements CurveProvider<Ed25519PointOps> {
    public static final Ed25519CurveParams CURVE = new Ed25519CurveParams();

    private Ed25519Provider() {}

    private static class SingletonHelper {
        private static final Ed25519Provider INSTANCE = new Ed25519Provider();
    }

    public static Ed25519Provider getInstance() {
        return SingletonHelper.INSTANCE;
    }

    @Override
    public ECKeyPair<Ed25519PointOps> generateKeyPair() {
        var keyPair = Ed25519.generateKeyPair();
        var publicKey = new Ed25519PublicKey(keyPair.getPublicKey());
        var privateKey = new Ed25519PrivateKey(keyPair.getSecretKey());

        return new Ed25519KeyPair(privateKey, publicKey);
    }

    @Override
    public SchnorrSignature sign(byte[] data, ECKeyPair<Ed25519PointOps> keyPair) {
        return keyPair.privateKey().encoded().read(privateKey -> {
            var signature = Ed25519.signDetached(data, privateKey);
            var r = Arrays.copyOfRange(signature, 0, 32);
            var s = Arrays.copyOfRange(signature, 32, 64);

            return new SchnorrSignature(r, s);
        });
    }

    @Override
    public boolean verify(byte[] data, Signature signature, ECPublicKey<Ed25519PointOps> publicKey) {
        if (!(signature instanceof SchnorrSignature sig)) {
            throw new IllegalArgumentException("Signature must be an instance of SchnorrSignature");
        }

        var encoded = sig.encode();

        return Ed25519.verifyDetached(data, encoded, publicKey.encoded());
    }

    @Override
    public boolean isValidPublicKey(byte[] key) {
        if (key == null || key.length != 32) {
            return false;
        }

        try {
            return CURVE.decodePoint(key).isValid();
        } catch (Exception e) {
            return false;
        }
    }

    @Override
    public TaprootSchnorrSigner schnorr() {
        throw new UnsupportedOperationException("Ed25519 is optimized for EdDSA. Using Schnorr with this curve is not recommended.");
    }

    @Override
    public Ed25519PublicKey getPublicKey(ECPrivateKey privateKey) {
        if (!(privateKey instanceof Ed25519PrivateKey)) {
            throw new IllegalArgumentException("Invalid private key type for Ed25519");
        }

        return privateKey.encoded().read(bytes -> {
            var rawKeyPair = Ed25519.fromSeed(bytes);
            var publicKey = new Ed25519PublicKey(rawKeyPair.getPublicKey());

            Arrays.fill(rawKeyPair.getSecretKey(), (byte) 0);

            return publicKey;
        });
    }

    @Override
    public SupportedCurve type() {
        return SupportedCurve.ED25519;
    }
}