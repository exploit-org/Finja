package org.exploit.crypto.curve;

import org.bouncycastle.crypto.generators.Ed25519KeyPairGenerator;
import org.bouncycastle.crypto.params.Ed25519KeyGenerationParameters;
import org.bouncycastle.crypto.params.Ed25519PrivateKeyParameters;
import org.bouncycastle.crypto.params.Ed25519PublicKeyParameters;
import org.bouncycastle.crypto.signers.Ed25519Signer;
import org.bouncycastle.jce.provider.BouncyCastleProvider;
import org.bouncycastle.math.ec.rfc8032.Ed25519;
import org.bouncycastle.util.BigIntegers;
import org.exploit.crypto.constant.SupportedCurve;
import org.exploit.crypto.key.ECKeyPair;
import org.exploit.crypto.key.ECPrivateKey;
import org.exploit.crypto.key.ECPublicKey;
import org.exploit.crypto.key.ed25519.Ed25519KeyPair;
import org.exploit.crypto.key.ed25519.Ed25519PrivateKey;
import org.exploit.crypto.key.ed25519.Ed25519PublicKey;
import org.exploit.crypto.schnorr.TaprootSchnorrSigner;
import org.exploit.crypto.signature.EdDSASignature;
import org.exploit.crypto.signature.Signature;
import org.exploit.crypto.utils.SensitiveBytes;

import java.security.SecureRandom;
import java.security.Security;
import java.util.Arrays;

public class Ed25519Provider implements CurveProvider {
    private static final SecureRandom RANDOM;
    private static final Ed25519KeyPairGenerator KEY_PAIR_GENERATOR;

    static {
        Security.insertProviderAt(new BouncyCastleProvider(), 1);

        try {
            RANDOM = SecureRandom.getInstanceStrong();

            KEY_PAIR_GENERATOR = new Ed25519KeyPairGenerator();
            KEY_PAIR_GENERATOR.init(new Ed25519KeyGenerationParameters(RANDOM));
        } catch (Exception e) {
            throw new IllegalStateException("Failed to initialize key pair generator", e);
        }
    }

    private Ed25519Provider() {}

    private static class SingletonHelper {
        private static final Ed25519Provider INSTANCE = new Ed25519Provider();
    }

    public static Ed25519Provider getInstance() {
        return SingletonHelper.INSTANCE;
    }

    @Override
    public ECKeyPair generateKeyPair() {
        var keyPair = KEY_PAIR_GENERATOR.generateKeyPair();

        var publicKey = new Ed25519PublicKey(((Ed25519PublicKeyParameters) keyPair.getPublic()).getEncoded());
        var privateKey = new Ed25519PrivateKey(SensitiveBytes.write(((Ed25519PrivateKeyParameters) keyPair.getPrivate())
                .getEncoded()));

        return new Ed25519KeyPair(privateKey, publicKey);
    }

    @Override
    public Signature sign(byte[] data, ECKeyPair keyPair) {
        var signer = new Ed25519Signer();
        var bytes = BigIntegers.asUnsignedByteArray(keyPair.privateKey().toBigInt());

        signer.init(true, new Ed25519PrivateKeyParameters(BigIntegers.asUnsignedByteArray(keyPair.privateKey().toBigInt())));

        signer.update(data, 0, data.length);
        var signature = signer.generateSignature();

        var r = Arrays.copyOfRange(signature, 0, 32);
        var s = Arrays.copyOfRange(signature, 32, 64);

        return new EdDSASignature(r, s);
    }

    @Override
    public boolean verify(byte[] data, Signature signature, ECPublicKey publicKey) {
        var verifier = new Ed25519Signer();
        verifier.init(false, new Ed25519PublicKeyParameters(BigIntegers.asUnsignedByteArray(32, publicKey.toBigInt())));
        verifier.update(data, 0, data.length);

        return verifier.verifySignature(signature.encode());
    }

    @Override
    public boolean isValidPublicKey(byte[] key) {
        if (key == null || key.length != 32) {
            return false;
        }

        var publicPoint = Ed25519.validatePublicKeyPartialExport(key, 0);

        return publicPoint != null;
    }

    @Override
    public TaprootSchnorrSigner schnorr() {
        throw new UnsupportedOperationException("Ed25519 is optimized for EdDSA. Using Schnorr with this curve is not recommended.");
    }

    @Override
    public ECPublicKey getPublicKey(ECPrivateKey privateKey) {
        var privateKeyBytes = privateKey.encoded().deobfuscate(bytes -> Arrays.copyOf(bytes, bytes.length));
        var privateKeyParams = new Ed25519PrivateKeyParameters(privateKeyBytes, 0);

        var publicKeyParams = privateKeyParams.generatePublicKey();

        return new Ed25519PublicKey(publicKeyParams.getEncoded());
    }

    @Override
    public SupportedCurve type() {
        return SupportedCurve.ED25519;
    }
}