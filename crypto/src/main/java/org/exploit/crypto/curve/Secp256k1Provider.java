package org.exploit.crypto.curve;

import org.bouncycastle.asn1.sec.SECNamedCurves;
import org.bouncycastle.asn1.x9.X9IntegerConverter;
import org.bouncycastle.crypto.digests.SHA256Digest;
import org.bouncycastle.crypto.params.ECDomainParameters;
import org.bouncycastle.crypto.params.ECPrivateKeyParameters;
import org.bouncycastle.crypto.params.ECPublicKeyParameters;
import org.bouncycastle.crypto.signers.ECDSASigner;
import org.bouncycastle.crypto.signers.HMacDSAKCalculator;
import org.bouncycastle.jcajce.provider.asymmetric.ec.BCECPrivateKey;
import org.bouncycastle.jcajce.provider.asymmetric.ec.BCECPublicKey;
import org.bouncycastle.jce.provider.BouncyCastleProvider;
import org.bouncycastle.math.ec.ECAlgorithms;
import org.bouncycastle.math.ec.ECPoint;
import org.bouncycastle.math.ec.FixedPointCombMultiplier;
import org.bouncycastle.math.ec.custom.sec.SecP256K1Curve;
import org.exploit.crypto.constant.SupportedCurve;
import org.exploit.crypto.key.ECKeyPair;
import org.exploit.crypto.key.ECPrivateKey;
import org.exploit.crypto.key.ECPublicKey;
import org.exploit.crypto.key.secp256k1.Secp256k1KeyPair;
import org.exploit.crypto.key.secp256k1.Secp256k1PrivateKey;
import org.exploit.crypto.key.secp256k1.Secp256k1PublicKey;
import org.exploit.crypto.schnorr.TaprootSchnorrSigner;
import org.exploit.crypto.signature.ECDSASignature;
import org.exploit.crypto.signature.Signature;

import java.math.BigInteger;
import java.security.KeyPairGenerator;
import java.security.Security;
import java.security.spec.ECGenParameterSpec;
import java.util.Arrays;

public class Secp256k1Provider implements CurveProvider {
    private static final KeyPairGenerator KEY_PAIR_GENERATOR;

    public static final ECDomainParameters CURVE;

    private static final BigInteger CURVE_ORDER;
    private static final BigInteger HALF_CURVE_ORDER;

    private static final String ALGORITHM = "ECDSA";
    private static final String CURVE_NAME = "secp256k1";
    private static final String PROVIDER = "BC";

    static {
        Security.insertProviderAt(new BouncyCastleProvider(), 1);

        CURVE = initializeCurve();
        CURVE_ORDER = CURVE.getN();

        HALF_CURVE_ORDER = CURVE_ORDER.shiftRight(1);

        KEY_PAIR_GENERATOR = initializeKeyPairGenerator();
    }

    private Secp256k1Provider() {}

    private static class SingletonHelper {
        private static final Secp256k1Provider INSTANCE = new Secp256k1Provider();
    }

    public static Secp256k1Provider getInstance() {
        return SingletonHelper.INSTANCE;
    }

    @Override
    public boolean isValidPublicKey(byte[] publicKeyBytes) {
        try {
            var point = CURVE.getCurve().decodePoint(publicKeyBytes);
            return !point.isInfinity() && point.isValid();
        } catch (Exception e) {
            return false;
        }
    }

    public boolean isValidKeyPair(ECPublicKey publicKey, ECPrivateKey privateKey) {
        return getPublicKey(privateKey).hex().equalsIgnoreCase(publicKey.hex());
    }

    @Override
    public TaprootSchnorrSigner schnorr() {
        return new TaprootSchnorrSigner();
    }

    @Override
    public Secp256k1KeyPair generateKeyPair() {
        var rawKeyPair = KEY_PAIR_GENERATOR.generateKeyPair();

        var privateKey = (BCECPrivateKey) rawKeyPair.getPrivate();
        var publicKey = (BCECPublicKey) rawKeyPair.getPublic();

        var privateKeyValue = privateKey.getD();

        var publicKeyBytes = publicKey.getQ().getEncoded(false);
        var publicKeyValue = new BigInteger(1, Arrays.copyOfRange(publicKeyBytes, 1, publicKeyBytes.length));

        return new Secp256k1KeyPair(Secp256k1PrivateKey.create(privateKeyValue), Secp256k1PublicKey.create(publicKeyValue));
    }

    @Override
    public ECDSASignature sign(byte[] data, ECKeyPair keyPair) {
        var signer = new ECDSASigner(new HMacDSAKCalculator(new SHA256Digest()));

        var privKey = new ECPrivateKeyParameters(keyPair.privateKey().toBigInt(), CURVE);
        signer.init(true, privKey);

        var components = signer.generateSignature(data);

        return normaliseSignature(components[0], components[1], keyPair.publicKey(), data);
    }

    @Override
    public boolean verify(byte[] data, Signature signature, ECPublicKey publicKey) {
        if (!(signature instanceof ECDSASignature ecdsaSignature))
            throw new IllegalArgumentException("Not ECDSA signature");

        var signer = new ECDSASigner();

        var publicKeyEncoded = publicKey.encoded();

        var params = new ECPublicKeyParameters(CURVE.getCurve().decodePoint(publicKeyEncoded), CURVE);
        signer.init(false, params);

        try {
            return signer.verifySignature(data, ecdsaSignature.getR(), ecdsaSignature.getS());
        } catch (NullPointerException e) {
            return false;
        }
    }

    @Override
    public Secp256k1PublicKey getPublicKey(ECPrivateKey privateKey) {
        var privKey = privateKey.toBigInt();

        if (privKey.bitLength() > CURVE.getN().bitLength()) {
            privKey = privKey.mod(CURVE.getN());
        }

        var point = new FixedPointCombMultiplier().multiply(CURVE.getG(), privKey);

        return Secp256k1PublicKey.create(Arrays.copyOfRange(point.getEncoded(false), 1, 65));
    }

    @Override
    public SupportedCurve type() {
        return SupportedCurve.SECP256K1;
    }

    public static ECDSASignature normaliseSignature(BigInteger nativeR, BigInteger nativeS, ECPublicKey publicKey, byte[] dataHash) {
        var s = nativeS;

        if (s.compareTo(HALF_CURVE_ORDER) > 0) {
            s = CURVE.getN().subtract(s);
        }

        var recId = -1;
        var publicKeyBI = publicKey.toBigInt();

        for (var i = 0; i < 4; i++) {
            var k = recoverFromSignature(i, nativeR, s, dataHash);

            if (k != null && k.equals(publicKeyBI)) {
                recId = i;
                break;
            }
        }

        if (recId == -1)
            throw new IllegalStateException("Could not construct a recoverable key. This should never happen.");

        return new ECDSASignature(nativeR, s, (byte) recId);
    }

    private static BigInteger recoverFromSignature(int recId, BigInteger r, BigInteger s, byte[] dataHash) {
        var n = CURVE.getN();
        var i = BigInteger.valueOf((long) recId / 2);
        var x = r.add(i.multiply(n));

        var prime = SecP256K1Curve.q;

        if (x.compareTo(prime) >= 0) {
            return null;
        }

        var rPoint = decompressKey(x, (recId & 1) == 1);

        if (!rPoint.multiply(n).isInfinity()) {
            return null;
        }

        var e = new BigInteger(1, dataHash);

        var eInv = BigInteger.ZERO.subtract(e).mod(n);
        var rInv = r.modInverse(n);
        var srInv = rInv.multiply(s).mod(n);
        var eInvrInv = rInv.multiply(eInv).mod(n);

        var q = ECAlgorithms.sumOfTwoMultiplies(CURVE.getG(), eInvrInv, rPoint, srInv);

        if (q.isInfinity()) {
            return null;
        }

        var qBytes = q.getEncoded(false);

        return new BigInteger(1, Arrays.copyOfRange(qBytes, 1, qBytes.length));
    }

    private static ECPoint decompressKey(final BigInteger xBN, final boolean yBit) {
        var x9 = new X9IntegerConverter();
        var compEnc = x9.integerToBytes(xBN, 1 + x9.getByteLength(CURVE.getCurve()));
        compEnc[0] = (byte) (yBit ? 0x03 : 0x02);

        return CURVE.getCurve().decodePoint(compEnc);
    }

    private static ECDomainParameters initializeCurve() {
        var params = SECNamedCurves.getByName(CURVE_NAME);
        return new ECDomainParameters(params.getCurve(), params.getG(), params.getN(), params.getH());
    }

    private static KeyPairGenerator initializeKeyPairGenerator() {
        try {
            var keyPairGenerator = KeyPairGenerator.getInstance(ALGORITHM, PROVIDER);
            var ecGenParameterSpec = new ECGenParameterSpec(CURVE_NAME);
            keyPairGenerator.initialize(ecGenParameterSpec);

            return keyPairGenerator;
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    public static BigInteger getCurveOrder() {
        return CURVE_ORDER;
    }

    public static BigInteger getHalfCurveOrder() {
        return HALF_CURVE_ORDER;
    }
}
