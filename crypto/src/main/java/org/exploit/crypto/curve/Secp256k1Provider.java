package org.exploit.crypto.curve;

import org.bouncycastle.util.encoders.Hex;
import org.exploit.crypto.constant.SupportedCurve;
import org.exploit.crypto.key.ECKeyPair;
import org.exploit.crypto.key.ECPrivateKey;
import org.exploit.crypto.key.ECPublicKey;
import org.exploit.crypto.key.secp256k1.Secp256k1KeyPair;
import org.exploit.crypto.key.secp256k1.Secp256k1PrivateKey;
import org.exploit.crypto.key.secp256k1.Secp256k1PublicKey;
import org.exploit.crypto.schnorr.TaprootSchnorrSigner;
import org.exploit.gmp.BigInt;
import org.exploit.secp256k1.Secp256k1;
import org.exploit.secp256k1.Secp256k1CurveParams;
import org.exploit.secp256k1.Secp256k1PointOps;
import org.exploit.tss.signature.ECDSASignature;
import org.exploit.tss.signature.SchnorrSignature;
import org.exploit.tss.signature.Signature;

import java.util.Arrays;

public class Secp256k1Provider implements CurveProvider<Secp256k1PointOps> {
    public static final BigInt Q = new BigInt(1, Hex.decodeStrict("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F"));
    public static final Secp256k1CurveParams CURVE = new Secp256k1CurveParams();

    private static final BigInt CURVE_ORDER = CURVE.getCurveOrder();
    private static final BigInt HALF_CURVE_ORDER = CURVE_ORDER.shiftRight(1);

    private Secp256k1Provider() {}

    private static class SingletonHelper {
        private static final Secp256k1Provider INSTANCE = new Secp256k1Provider();
    }

    public static Secp256k1Provider getInstance() {
        return SingletonHelper.INSTANCE;
    }

    @Override
    public boolean isValidPublicKey(byte[] publicKeyBytes) {
        try {
            return CURVE.decodePoint(publicKeyBytes).isValid();
        } catch (Exception e) {
            return false;
        }
    }

    @Override
    public TaprootSchnorrSigner schnorr() {
        return new TaprootSchnorrSigner();
    }

    @Override
    public Secp256k1KeyPair generateKeyPair() {
        var rawKeyPair = Secp256k1.generateKeyPair();

        var privateKey = new Secp256k1PrivateKey(rawKeyPair.getSecretKey());
        var publicKey = new Secp256k1PublicKey(rawKeyPair.getPublicKey());

        return new Secp256k1KeyPair(privateKey, publicKey);
    }

    @Override
    public ECDSASignature sign(byte[] data, ECKeyPair<Secp256k1PointOps> keyPair) {
        return keyPair.privateKey().encoded().read(bytes -> {
            var signature = Secp256k1.signRecoverable(data, bytes);
            var r = Arrays.copyOfRange(signature, 0, 32);
            var s = Arrays.copyOfRange(signature, 32, 64);
            var recId = signature[64];

            return new ECDSASignature(r, s, recId);
        });
    }

    @Override
    public boolean verify(byte[] data, Signature signature, ECPublicKey<Secp256k1PointOps> publicKey) {
        if (signature instanceof SchnorrSignature schnorr) {
            return Secp256k1.taprootVerify(data, schnorr.encode(), publicKey.encoded(), new byte[0]);
        }

        if (!(signature instanceof ECDSASignature ecdsaSignature))
            throw new IllegalArgumentException("Not ECDSA signature");

        var sigEncoded = ecdsaSignature.encode();

        return Secp256k1.verifyRecoverable(data, sigEncoded, publicKey.compress());
    }

    @Override
    public Secp256k1PublicKey getPublicKey(ECPrivateKey privateKey) {
        return privateKey.encoded().read(bytes -> new Secp256k1PublicKey(Secp256k1.getPublicKey(bytes)));
    }

    @Override
    public SupportedCurve type() {
        return SupportedCurve.SECP256K1;
    }

    public static BigInt getCurveOrder() {
        return CURVE_ORDER;
    }

    public static BigInt getHalfCurveOrder() {
        return HALF_CURVE_ORDER;
    }
}
