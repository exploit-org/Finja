package org.exploit.crypto;

import at.favre.lib.bytes.Bytes;
import org.bouncycastle.util.BigIntegers;
import org.exploit.crypto.key.ECPrivateKey;
import org.exploit.crypto.key.secp256k1.Secp256k1PrivateKey;

import java.math.BigInteger;
import java.util.Arrays;

public final class WIF {
    private WIF() {
    }

    public static String create(ECPrivateKey privateKey, byte networkByte) {
        var s = privateKey.toBigInt();

        var buf = BigIntegers.asUnsignedByteArray(32, s);

        var extendedBytes = Bytes.from(networkByte).append(buf)
                .append((byte) 0x01)
                .array();

        var checksum = Hash.checksum(extendedBytes);

        var wif = Bytes.wrap(extendedBytes).append(checksum)
                .array();

        return Base58.getInstance().encode(wif);
    }

    public static Secp256k1PrivateKey recoverKey(byte[] wif, byte networkByte) {
        return recoverKey(wif, networkByte, Base58.DEFAULT_ALPHABET);
    }

    public static Secp256k1PrivateKey recoverKey(byte[] wif, byte networkByte, String alphabet) {
        var data = Base58.getInstance(alphabet).decode(new String(wif));

        if (data.length != 37 && data.length != 38)
            throw new IllegalArgumentException("Invalid WIF format length");

        if (data[0] != networkByte || (data.length == 38 && data[33] != 0x01))
            throw new IllegalArgumentException("Invalid WIF format");

        var checksum = Hash.checksum(Arrays.copyOfRange(data, 0, data.length - 4));

        if (!Arrays.equals(checksum, Arrays.copyOfRange(data, data.length - 4, data.length)))
            throw new IllegalArgumentException("Invalid WIF checksum");

        var privateKeyBytes = Arrays.copyOfRange(data, 1, 33);

        return Secp256k1PrivateKey.create(new BigInteger(1, privateKeyBytes));
    }
}