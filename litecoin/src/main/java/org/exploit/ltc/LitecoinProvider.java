package org.exploit.ltc;

import org.exploit.btc.BitcoinProtocolProvider;
import org.exploit.btc.address.BigBitcoinProtocolWallet;
import org.exploit.btc.address.BitcoinProtocolWallet;
import org.exploit.btc.constant.AddressType;
import org.exploit.btc.constant.FeePolicy;
import org.exploit.btc.constant.SigHash;
import org.exploit.btc.explorer.BitcoinExplorer;
import org.exploit.btc.fee.BitcoinFeeProvider;
import org.exploit.btc.generator.BitcoinAddressGenerator;
import org.exploit.btc.generator.LegacyAddressGenerator;
import org.exploit.btc.generator.SegWitAddressGenerator;
import org.exploit.btc.generator.TaprootAddressGenerator;
import org.exploit.btc.model.BitcoinMeta;
import org.exploit.btc.protocol.script.BitcoinScript;
import org.exploit.btc.utils.BitcoinScripts;
import org.exploit.crypto.Base58;
import org.exploit.finja.core.ValueConverter;
import org.exploit.finja.core.constant.Asset;
import org.exploit.finja.core.constant.NetworkType;
import org.exploit.finja.core.converter.MathConstantConverter;
import org.exploit.finja.core.key.ECKeyManager;
import org.exploit.finja.listener.ListenerProvider;
import org.exploit.ltc.address.LitecoinWallet;

import java.util.List;

import static org.exploit.ltc.constant.LitecoinNetworkBytes.PUBLIC_KEY_MAINNET_P2PKH;
import static org.exploit.ltc.constant.LitecoinNetworkBytes.PUBLIC_KEY_TESTNET_P2PKH;

public class LitecoinProvider implements BitcoinProtocolProvider {
    private static final ValueConverter CONVERTER = new MathConstantConverter(8);

    private final BitcoinMeta meta;
    private final BitcoinExplorer explorer;
    private final ListenerProvider<BitcoinProtocolProvider> listenerProvider;
    private final BitcoinFeeProvider feeProvider;

    private LitecoinProvider(BitcoinMeta meta, BitcoinExplorer explorer, ListenerProvider<BitcoinProtocolProvider> listenerProvider, BitcoinFeeProvider feeProvider) {
        this.meta = meta;
        this.explorer = explorer;
        this.listenerProvider = listenerProvider;
        this.feeProvider = feeProvider;
    }

    @Override
    public Asset asset() {
        return Asset.LTC;
    }

    @Override
    public BigBitcoinProtocolWallet createBigWallet(List<BitcoinProtocolWallet> wallets) {
        return new BigBitcoinProtocolWallet(this, wallets, SigHash.SIGHASH_ALL);
    }

    @Override
    public LitecoinWallet createWallet(String publicAddress, ECKeyManager keyManager) {
        return new LitecoinWallet(this, publicAddress, keyManager);
    }

    @Override
    public BitcoinAddressGenerator generator(NetworkType network, AddressType type) {
        return switch (type) {
            case LEGACY -> network.isTest() ? new LegacyAddressGenerator(asset(), PUBLIC_KEY_TESTNET_P2PKH)
                    : new LegacyAddressGenerator(asset(), PUBLIC_KEY_MAINNET_P2PKH);

            case SEGWIT -> network.isTest() ? new SegWitAddressGenerator(asset(), "tltc")
                    : new SegWitAddressGenerator(asset(), "ltc");

            case TAPROOT -> network.isTest() ? new TaprootAddressGenerator(asset(), "tltc")
                    : new TaprootAddressGenerator(asset(), "ltc");

            case CASH_ADDR -> throw new IllegalArgumentException("Litecoin does not support CashAddr");
        };
    }

    @Override
    public BitcoinScript getScript(String address) {
        if (address.startsWith("ltc1") || address.startsWith("tltc1")) {
            return BitcoinScripts.resolveWitness(address);
        }

        if (!Base58.getInstance().isValid(address))
            throw new IllegalArgumentException("Invalid address: " + address);

        var decoded = Base58.getInstance().decode(address);
        var prefix = decoded[0];

        if (prefix == (byte) 111 || prefix == (byte) 48)
            return BitcoinScripts.P2PKH;
        else if (prefix == (byte) 5 || prefix == (byte) 196)
            return BitcoinScripts.P2SH;
        else
            throw new IllegalArgumentException("Unknown address type: " + address);
    }

    @Override
    public ValueConverter converter() {
        return CONVERTER;
    }

    @Override
    public BitcoinExplorer explorer() {
        return explorer;
    }

    @Override
    public BitcoinMeta meta() {
        return meta;
    }

    @Override
    public ListenerProvider<BitcoinProtocolProvider> listenerProvider() {
        return listenerProvider;
    }

    @Override
    public BitcoinFeeProvider feeProvider() {
        return feeProvider;
    }

    public static Builder newBuilder() {
        return new Builder();
    }

    public static class Builder {
        private BitcoinMeta meta = new BitcoinMeta(NetworkType.MAIN, AddressType.SEGWIT, FeePolicy.NORMAL);

        private BitcoinExplorer explorer;
        private ListenerProvider<BitcoinProtocolProvider> listenerProvider;
        private BitcoinFeeProvider feeProvider;

        public Builder meta(BitcoinMeta meta) {
            this.meta = meta;
            return this;
        }

        public Builder explorer(BitcoinExplorer explorer) {
            this.explorer = explorer;
            return this;
        }

        public Builder listenerProvider(ListenerProvider<BitcoinProtocolProvider> listenerProvider) {
            this.listenerProvider = listenerProvider;
            return this;
        }

        public Builder feeProvider(BitcoinFeeProvider feeProvider) {
            this.feeProvider = feeProvider;
            return this;
        }

        public LitecoinProvider build() {
            return new LitecoinProvider(meta, explorer, listenerProvider, feeProvider);
        }
    }
}
