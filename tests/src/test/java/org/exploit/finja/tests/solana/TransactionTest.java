package org.exploit.finja.tests.solana;

import org.exploit.crypto.Base58;
import org.exploit.crypto.constant.SupportedCurve;
import org.exploit.finja.core.constant.AmountUnit;
import org.exploit.finja.core.key.InMemoryKey;
import org.exploit.finja.core.model.Amount;
import org.exploit.finja.core.model.WebData;
import org.exploit.finja.utils.Jackson;
import org.exploit.finja.utils.SensitiveBytes;
import org.exploit.jettyx.auth.NoAuth;
import org.exploit.sol.SolanaProvider;
import org.exploit.sol.model.Transaction;
import org.junit.jupiter.api.Test;

import java.math.BigDecimal;
import java.math.BigInteger;

import static org.junit.jupiter.api.Assertions.*;

public class TransactionTest {
    private final SolanaProvider provider = SolanaProvider.newBuilder()
            .node(WebData.create("https://api.testnet.solana.com", new NoAuth()))
            .build();

    // NOTE before running this test. Target Solana address should have enough rental balance to accept small amounts.
    @Test
    public void transactionTest() throws InterruptedException {
        var privateKeyDecoded = Base58.getInstance().decode(System.getenv("SOL_PRIVATE_KEY"));
        var privateKey = SensitiveBytes.write(privateKeyDecoded);

        var wallet = provider.createWallet(new InMemoryKey(SupportedCurve.ED25519, privateKey));
        assertEquals("Ag5NFnBsxRYRTT7SGpAfaZeyYeUYfATmM26LNCXrzuiD", wallet.publicAddress());

        var targetAddress = "GGiiF6251u7rkeXeEcnqA5ptMa2vtYcW8Y3YkWXknfkz";
        var amount = new Amount(new BigDecimal("0.00001"), AmountUnit.HUMAN);

        var tx = wallet.transaction(targetAddress, amount);
        assertNotEquals(0L, tx.fee());

        var receipt = tx.send();
        var txid = receipt.txid();
        assertNotNull(txid);


        var blockchainTransaction = provider.getClient().getTransaction(txid).getResult();

        Transaction sentTransaction;

        do {
            sentTransaction = provider.getClient().getTransaction(txid).getResult();

            if (sentTransaction == null) {
                Thread.sleep(1000);
                continue;
            }

            var instructions = blockchainTransaction.getTransaction()
                    .getMessage()
                    .getInstructions()
                    .stream()
                    .filter(instruction -> instruction.getParsed().getType().equalsIgnoreCase("transfer"))
                    .findFirst()
                    .orElseThrow();

            var transfer = Jackson.convert(instructions.getParsed().getInfo(), Transaction.TransactionData.Transfer.class);
            assertEquals(0, amount.asUnit(provider).compareTo(BigInteger.valueOf(transfer.getLamports())));
        } while (sentTransaction == null);
    }
}
