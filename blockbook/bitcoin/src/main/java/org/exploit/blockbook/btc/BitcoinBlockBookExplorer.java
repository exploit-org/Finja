package org.exploit.blockbook.btc;

import at.favre.lib.bytes.Bytes;
import com.fasterxml.jackson.databind.JsonNode;
import org.bouncycastle.util.encoders.Hex;
import org.exploit.blockbook.BlockBookApi;
import org.exploit.blockbook.BlockBookEventFetcher;
import org.exploit.blockbook.BlockBookEventTransformer;
import org.exploit.blockbook.model.UnspentOutput;
import org.exploit.blockbook.model.transaction.BlockBookTransaction;
import org.exploit.btc.BitcoinProtocolProvider;
import org.exploit.btc.explorer.BitcoinExplorer;
import org.exploit.btc.protocol.UTXO;
import org.exploit.finja.core.EventFetcher;
import org.exploit.finja.core.exception.TransactionSendException;
import org.exploit.finja.core.model.CommonBlock;
import org.exploit.finja.core.model.CommonTransaction;
import org.exploit.finja.core.model.WebData;

import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.TimeUnit;
import java.util.stream.Collectors;

public class BitcoinBlockBookExplorer implements BitcoinExplorer {
    private final WebData webData;
    private final BlockBookApi api;

    public BitcoinBlockBookExplorer(WebData webData) {
        this.webData = webData;
        this.api = BlockBookApi.create(webData);
    }

    public BlockBookApi api() {
        return api;
    }

    @Override
    public WebData getWebData() {
        return webData;
    }

    @Override
    public List<UTXO> utxos(String address) {
        var unspentOutputs = BlockBookApi.handle(api.getUnspentOutputs(address));
        List<CompletableFuture<UTXO>> futures = new ArrayList<>();

        for (var out : unspentOutputs) {
            var future = CompletableFuture.supplyAsync(() -> {
                var tx = BlockBookApi.handle(api.getTransaction(out.getTxid()));
                return convertUtxo(out, tx);
            });

            futures.add(future);

            try {
                TimeUnit.MILLISECONDS.sleep(300);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                throw new IllegalStateException(e);
            }
        }

        var allOf = CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]));
        allOf.join();

        return futures.stream()
                .map(CompletableFuture::join)
                .collect(Collectors.toList());
    }

    @Override
    public String push(String hex) {
        var node = api.push(hex).body();

        if (node.has("result"))
            return node.get("result").asText();

        var error = Optional.ofNullable(node.get("error"))
                .map(JsonNode::asText)
                .orElse("Unknown error");

        throw new TransactionSendException(error);
    }

    @Override
    public EventFetcher createEventFetcher(BitcoinProtocolProvider provider) {
        return new BlockBookEventFetcher(api, new BlockBookEventTransformer(provider.asset(), provider.converter()));
    }

    @Override
    public CommonTransaction getTransaction(String txid) {
        throw new UnsupportedOperationException("TODO");
    }

    @Override
    public CommonBlock getFullBlock(long height) {
        throw new UnsupportedOperationException("TODO");
    }

    private static UTXO convertUtxo(UnspentOutput output, BlockBookTransaction tx) {
        var hash = tx.getTxid();
        var reversedHash = Bytes.wrap(Hex.decode(hash))
                .reverse()
                .encodeHex();

        var n = output.getVout();
        var vout = tx.getVout().get(n);

        var script = vout.getHex();
        var value = Long.parseLong(output.getValue());

        return new UTXO(reversedHash, n, script, value, tx.getConfirmations());
    }
}
