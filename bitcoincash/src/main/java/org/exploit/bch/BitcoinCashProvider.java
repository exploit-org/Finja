package org.exploit.bch;

import org.exploit.bch.address.BitcoinCashWallet;
import org.exploit.bch.generator.BitcoinCashAddressGenerator;
import org.exploit.bch.script.P2PKHCashScript;
import org.exploit.bch.script.P2SHCashScript;
import org.exploit.bch.util.CashAddr;
import org.exploit.bch.validator.BitcoinCashAddressValidator;
import org.exploit.btc.BitcoinProtocolProvider;
import org.exploit.btc.address.BigBitcoinProtocolWallet;
import org.exploit.btc.address.BitcoinProtocolWallet;
import org.exploit.btc.constant.AddressType;
import org.exploit.btc.constant.FeePolicy;
import org.exploit.btc.constant.SigHash;
import org.exploit.btc.explorer.BitcoinExplorer;
import org.exploit.btc.fee.BitcoinFeeProvider;
import org.exploit.btc.generator.BitcoinAddressGenerator;
import org.exploit.btc.generator.LegacyAddressGenerator;
import org.exploit.btc.model.BitcoinMeta;
import org.exploit.btc.protocol.script.BitcoinScript;
import org.exploit.btc.utils.BitcoinScripts;
import org.exploit.crypto.Base58;
import org.exploit.finja.core.AddressValidator;
import org.exploit.finja.core.CryptoWallet;
import org.exploit.finja.core.ValueConverter;
import org.exploit.finja.core.constant.Asset;
import org.exploit.finja.core.constant.NetworkType;
import org.exploit.finja.core.converter.MathConstantConverter;
import org.exploit.finja.core.key.ECKeyManager;
import org.exploit.finja.listener.ListenerProvider;
import org.exploit.secp256k1.Secp256k1PointOps;

import java.util.List;

public class BitcoinCashProvider implements BitcoinProtocolProvider {
    private static final ValueConverter CONVERTER = new MathConstantConverter(8);

    private final BitcoinMeta meta;

    private final BitcoinExplorer explorer;
    private final ListenerProvider<BitcoinProtocolProvider> listenerProvider;
    private final BitcoinFeeProvider feeProvider;

    private BitcoinCashProvider(
            BitcoinMeta meta, BitcoinExplorer explorer,
            ListenerProvider<BitcoinProtocolProvider> listenerProvider, BitcoinFeeProvider feeProvider
    ) {
        this.meta = meta;
        this.explorer = explorer;
        this.listenerProvider = listenerProvider;
        this.feeProvider = feeProvider;
    }

    @Override
    public BitcoinExplorer explorer() {
        return explorer;
    }

    @Override
    public BitcoinMeta meta() {
        return meta;
    }

    @Override
    public ListenerProvider<BitcoinProtocolProvider> listenerProvider() {
        return listenerProvider;
    }

    @Override
    public BitcoinFeeProvider feeProvider() {
        return feeProvider;
    }

    @Override
    public BitcoinAddressGenerator generator(NetworkType network, AddressType type) {
        return switch (type) {
            case LEGACY -> network.isTest() ? new LegacyAddressGenerator(asset(), (byte) 0x6f)
                    : new LegacyAddressGenerator(asset(), (byte) 0x00);

            case CASH_ADDR -> new BitcoinCashAddressGenerator(network);

            default -> throw new IllegalArgumentException("Unknown address type: " + type);
        };
    }

    @Override
    public BigBitcoinProtocolWallet createBigWallet(List<BitcoinProtocolWallet> wallets) {
        return new BigBitcoinProtocolWallet(this, wallets, SigHash.SIGHASH_FORKID);
    }

    @Override
    public BitcoinScript getScript(String address) {
        var finalAddress = CashAddr.splitAddress(address);

        if (finalAddress.startsWith("q")) return new P2PKHCashScript();
        if (finalAddress.startsWith("p")) return new P2SHCashScript();

        if (!Base58.getInstance().isValid(address))
            throw new IllegalArgumentException("Invalid address: " + address);

        var decoded = Base58.getInstance().decode(finalAddress);
        var prefix = decoded[0];

        if (prefix == 0x00 || prefix == 0x6F) {
            return BitcoinScripts.P2PKH;
        } else if (prefix == 0x05 || prefix == (byte) 0xC4) {
            return BitcoinScripts.P2SH;
        } else {
            throw new IllegalArgumentException("Unknown address type: " + address);
        }
    }

    @Override
    public Asset asset() {
        return Asset.BCH;
    }

    @Override
    public CryptoWallet createWallet(String publicAddress, ECKeyManager<Secp256k1PointOps> keyManager) {
        return new BitcoinCashWallet(this, publicAddress, keyManager);
    }

    @Override
    public AddressValidator validator() {
        return new BitcoinCashAddressValidator(this);
    }

    @Override
    public ValueConverter converter() {
        return CONVERTER;
    }

    public static Builder newBuilder() {
        return new Builder();
    }

    public static class Builder {
        private BitcoinMeta meta = new BitcoinMeta(NetworkType.MAIN, AddressType.CASH_ADDR, FeePolicy.NORMAL);

        private BitcoinExplorer explorer;
        private ListenerProvider<BitcoinProtocolProvider> listenerProvider;
        private BitcoinFeeProvider feeProvider;

        public Builder meta(BitcoinMeta meta) {
            this.meta = meta;
            return this;
        }

        public Builder explorer(BitcoinExplorer explorer) {
            this.explorer = explorer;
            return this;
        }

        public Builder listenerProvider(ListenerProvider<BitcoinProtocolProvider> listenerProvider) {
            this.listenerProvider = listenerProvider;
            return this;
        }

        public Builder feeProvider(BitcoinFeeProvider feeProvider) {
            this.feeProvider = feeProvider;
            return this;
        }

        public BitcoinCashProvider build() {
            return new BitcoinCashProvider(meta, explorer, listenerProvider, feeProvider);
        }
    }
}
