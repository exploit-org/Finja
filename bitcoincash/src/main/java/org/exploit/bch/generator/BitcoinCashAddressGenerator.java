package org.exploit.bch.generator;

import at.favre.lib.bytes.Bytes;
import lombok.RequiredArgsConstructor;
import org.exploit.bch.util.CashAddr;
import org.exploit.btc.generator.BitcoinAddressGenerator;
import org.exploit.crypto.Hash;
import org.exploit.crypto.curve.Secp256k1Provider;
import org.exploit.crypto.key.ECKeyPair;
import org.exploit.crypto.key.ECPublicKey;
import org.exploit.finja.core.constant.Asset;
import org.exploit.finja.core.constant.NetworkType;
import org.exploit.finja.core.model.CommonAddress;
import org.exploit.secp256k1.Secp256k1PointOps;

import java.io.ByteArrayOutputStream;

@RequiredArgsConstructor
public class BitcoinCashAddressGenerator implements BitcoinAddressGenerator {
    private static final String MAINNET_PREFIX = "bitcoincash";
    private static final String TESTNET_PREFIX = "bchtest";

    private static final long[] POLYMOD_GENERATORS = {
            0x98f2bc8e61L, 0x79b76d99e2L, 0xf33e5fb3c4L, 0xae2eabe2a8L, 0x1e4f43e470L
    };

    private static final byte VERSION = 0x00;

    private final NetworkType network;

    @Override
    public CommonAddress generate() {
        var keyPair = Secp256k1Provider.getInstance().generateKeyPair();
        return generate(keyPair);
    }

    @Override
    public String encodePublicAddress(ECPublicKey<Secp256k1PointOps> publicKey) {
        var publicKeyBytes = publicKey.compress();
        var hash160 = Hash.hash160(publicKeyBytes);

        var prefix = getNetworkPrefix();

        return encodeCashAddr(prefix, hash160);
    }

    @Override
    public CommonAddress generate(ECKeyPair<Secp256k1PointOps> keyPair) {
        var cashAddress = encodePublicAddress(keyPair.publicKey());
        var memory = keyPair.privateKey().encoded();

        return new CommonAddress(cashAddress, memory);
    }

    @Override
    public Asset asset() {
        return Asset.BCH;
    }

    private String getNetworkPrefix() {
        return network == NetworkType.MAIN ? MAINNET_PREFIX : TESTNET_PREFIX;
    }

    private static String encodeCashAddr(String prefix, byte[] hash160) {
        var payload = versionAndHash(hash160);
        var data = convertTo5BitArrayWithPadding(payload);

        var checksum = checksumOf(prefix, data);
        var combined = dataAndChecksum(data, checksum);

        return prefix + ":" + CashAddr.encode(combined);
    }

    private static byte[] versionAndHash(byte[] hash160) {
        return Bytes.from(VERSION).append(hash160).array();
    }

    private static byte[] convertTo5BitArrayWithPadding(byte[] payload) {
        ByteArrayOutputStream stream = new ByteArrayOutputStream();
        int accumulator = 0;
        int bits = 0;
        for (byte b : payload) {
            accumulator = (accumulator << 8) | (b & 0xff);
            bits += 8;
            while (bits >= 5) {
                stream.write((accumulator >> (bits - 5)) & 0x1f);
                bits -= 5;
            }
        }

        if (bits > 0) {
            stream.write((accumulator << (5 - bits)) & 0x1f);
        }
        return stream.toByteArray();
    }

    private static byte[] checksumOf(String prefix, byte[] data) {
        var prefixData = expandPrefix(prefix);
        var values = new int[prefixData.length + data.length + 8];
        System.arraycopy(prefixData, 0, values, 0, prefixData.length);

        for (var i = 0; i < data.length; i++) {
            values[prefixData.length + i] = data[i];
        }

        for (int i = 0; i < 8; i++) {
            values[prefixData.length + data.length + i] = 0;
        }

        var polymod = polymod(values) ^ 1;
        var checksum = new byte[8];

        for (var i = 0; i < 8; i++) {
            checksum[i] = (byte) ((polymod >>> (5 * (7 - i))) & 0x1f);
        }

        return checksum;
    }

    private static int[] expandPrefix(String prefix) {
        var result = new int[prefix.length() + 1];
        for (var i = 0; i < prefix.length(); i++) {
            result[i] = prefix.charAt(i) & 0x1f;
        }
        result[prefix.length()] = 0;
        return result;
    }

    private static long polymod(int[] values) {
        long c = 1;
        for (var v : values) {
            var c0 = (int) (c >>> 35);
            c = ((c & 0x07ffffffffL) << 5) ^ v;
            for (var j = 0; j < 5; j++) {
                if ((c0 & (1 << j)) != 0) {
                    c ^= POLYMOD_GENERATORS[j];
                }
            }
        }
        return c;
    }

    private static byte[] dataAndChecksum(byte[] data, byte[] checksum) {
        return Bytes.wrap(data).append(checksum).array();
    }
}