package org.exploit.sol.protocol.message;

import org.exploit.crypto.Base58;
import org.exploit.sol.protocol.AccountMeta;
import org.exploit.sol.util.ShortVec;

import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.List;

public class MessageSerializer {
    private final Message message;

    public MessageSerializer(Message message) {
        this.message = message;
    }

    public byte[] serialize() {
        if (message.getRecentBlockhash() == null) {
            throw new IllegalArgumentException("recentBlockhash required");
        }

        if (message.getInstructions().isEmpty()) {
            throw new IllegalArgumentException("No instructions provided");
        }

        message.initMessageHeader();

        var keysList = message.getSortedAccountKeys();
        var accountKeysSize = keysList.size();

        var accountAddressesLength = ShortVec.encodeLength(accountKeysSize);
        var compiledInstructions = compileInstructions(message);

        var instructionsLength = ShortVec.encodeLength(compiledInstructions.size());

        var bufferSize = MessageHeader.HEADER_LENGTH + Message.RECENT_BLOCK_HASH_LENGTH + accountAddressesLength.length
                + (accountKeysSize * 32) + instructionsLength.length
                + compiledInstructions.stream().mapToInt(CompiledInstruction::getLength).sum();

        var out = ByteBuffer.allocate(bufferSize);

        var accountKeysBuff = ByteBuffer.allocate(accountKeysSize * 32);

        for (var accountMeta : keysList) {
            accountKeysBuff.put(accountMeta.getPublicKey().encoded());

            updateMessageHeader(message.getMessageHeader(), accountMeta);
        }

        out.put(message.getMessageHeader().toByteArray());

        out.put(accountAddressesLength);
        out.put(accountKeysBuff.array());

        out.put(Base58.getInstance().decode(message.getRecentBlockhash()));

        out.put(instructionsLength);

        for (var compiledInstruction : compiledInstructions) {
            out.put(compiledInstruction.programIdIndex);
            out.put(compiledInstruction.keyIndicesCount);
            out.put(compiledInstruction.keyIndices);
            out.put(compiledInstruction.dataLength);
            out.put(compiledInstruction.data);
        }

        return out.array();
    }

    private void updateMessageHeader(MessageHeader header, AccountMeta accountMeta) {
        if (accountMeta.isSigner()) {
            header.numRequiredSignatures += 1;
            if (!accountMeta.isWriteable()) {
                header.numReadonlySignedAccounts += 1;
            }
        } else {
            if (!accountMeta.isWriteable()) {
                header.numReadonlyUnsignedAccounts += 1;
            }
        }
    }

    private List<CompiledInstruction> compileInstructions(Message message) {
        List<CompiledInstruction> compiledInstructions = new ArrayList<>();

        for (var instruction : message.getInstructions()) {
            var keysSize = instruction.getAccounts().size();

            var keyIndices = new byte[keysSize];
            for (var i = 0; i < keysSize; i++) {
                keyIndices[i] = (byte) message.getAccountKeyManager().findAccountIndex(instruction.getAccounts().get(i).getPublicKey());
            }

            var compiledInstruction = new CompiledInstruction();

            compiledInstruction.programIdIndex = (byte) message.getAccountKeyManager()
                    .findAccountIndex(instruction.getProgramId());

            compiledInstruction.keyIndicesCount = ShortVec.encodeLength(keysSize);
            compiledInstruction.keyIndices = keyIndices;
            compiledInstruction.dataLength = ShortVec.encodeLength(instruction.getData().length);
            compiledInstruction.data = instruction.getData();

            compiledInstructions.add(compiledInstruction);
        }

        return compiledInstructions;
    }
}