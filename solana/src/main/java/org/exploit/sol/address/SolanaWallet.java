package org.exploit.sol.address;

import lombok.AllArgsConstructor;
import lombok.Data;
import org.exploit.crypto.Base58;
import org.exploit.crypto.key.ed25519.Ed25519PublicKey;
import org.exploit.ed25519.Ed25519PointOps;
import org.exploit.finja.core.CryptoWallet;
import org.exploit.finja.core.OutgoingTransaction;
import org.exploit.finja.core.constant.Flag;
import org.exploit.finja.core.key.ECKeyManager;
import org.exploit.finja.core.model.Amount;
import org.exploit.finja.core.model.Recipient;
import org.exploit.finja.core.model.Value;
import org.exploit.sol.SolanaProvider;
import org.exploit.sol.instruction.TransferInstruction;
import org.exploit.sol.model.request.Commitment;
import org.exploit.sol.protocol.SolanaOutgoing;
import org.exploit.sol.protocol.Transaction;

import java.util.List;

public class SolanaWallet implements CryptoWallet {
    private final SolanaProvider provider;
    private final String publicAddress;
    private final ECKeyManager<Ed25519PointOps> keyManager;

    public SolanaWallet(SolanaProvider provider, String publicAddress, ECKeyManager<Ed25519PointOps> keyManager) {
        this.provider = provider;
        this.publicAddress = publicAddress;
        this.keyManager = keyManager;
    }

    @Override
    public String publicAddress() {
        return publicAddress;
    }

    @Override
    public OutgoingTransaction transaction(String to, Amount amount, int flags) {
        return transaction(List.of(new Recipient() {{
            setAddress(to);
            setAmount(amount);
        }}));
    }

    @Override
    public OutgoingTransaction transaction(List<Recipient> recipients, int flags) {
        var programs = recipients.stream()
                .map(r -> buildReceiver(r.getAddress(), r.getAmount()))
                .map(SolanaReceiver::transfer)
                .toList();

        var hash = provider.getClient().getLatestBlockHash(Commitment.finalized())
                .getResult()
                .getValue()
                .getBlockhash();

        var txBuilder = Transaction.newBuilder()
                .instructions(programs)
                .feePayer(keyManager.getPublicKey())
                .recentBlockHash(hash);

        var tempTx = txBuilder.build();
        var totalFee = provider.getClient().getFeeForMessage(tempTx.toMessage64(), Commitment.finalized())
                .getResult().getValue();

        var finalPrograms = adjustProgramsForFee(programs, totalFee, flags);
        var transaction = txBuilder.instructions(finalPrograms).build();
        transaction.sign(keyManager);

        return new SolanaOutgoing(provider, transaction, totalFee);
    }

    private List<TransferInstruction> adjustProgramsForFee(List<TransferInstruction> programs, long totalFee, int flags) {
        if ((flags & Flag.INCLUDE_FEE) != 0) {
            var totalLamports = programs.stream()
                    .mapToLong(TransferInstruction::getLamports)
                    .sum();

            return programs.stream()
                    .map(program -> {
                        var originalAmount = program.getLamports();
                        var feeShare = (originalAmount * totalFee) / totalLamports;
                        var newAmount = originalAmount - feeShare;

                        if (newAmount < 0)
                            throw new IllegalArgumentException("Adjustment results in negative amount for recipient");

                        return new TransferInstruction(program.getFrom(), program.getTo(), newAmount);
                    })
                    .toList();
        } else {
            return programs;
        }
    }

    private SolanaReceiver buildReceiver(String to, Amount amount) {
        var pubKey = (Ed25519PublicKey) keyManager.getPublicKey();
        var toKey = Ed25519PublicKey.create(Base58.getInstance().decode(to));
        var lamports = amount.asUnit(provider).longValue();

        return new SolanaReceiver(pubKey, toKey, lamports);
    }

    @Override
    public Value balance() {
        return provider.balanceService().balance(publicAddress);
    }

    @Override
    public void erase() {
        keyManager.erase();
    }

    @Data
    @AllArgsConstructor
    private static class SolanaReceiver {
        private final Ed25519PublicKey signingPublicKey;
        private final Ed25519PublicKey receiver;
        private final long lamports;

        public TransferInstruction transfer() {
            return new TransferInstruction(signingPublicKey, receiver, lamports);
        }
    }
}
