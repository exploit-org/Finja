package org.exploit.sol.fetcher;

import com.fasterxml.jackson.databind.JsonNode;
import lombok.AllArgsConstructor;
import lombok.Data;
import org.exploit.finja.core.EventFetcher;
import org.exploit.finja.core.constant.Asset;
import org.exploit.finja.core.constant.TxType;
import org.exploit.finja.core.event.TxnEvent;
import org.exploit.finja.core.model.Value;
import org.exploit.finja.utils.Jackson;
import org.exploit.sol.SolanaProvider;
import org.exploit.sol.model.RpcResult;
import org.exploit.sol.model.SignatureStatuses;
import org.exploit.sol.model.Transaction;
import org.exploit.sol.model.TransactionSignature;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

import java.math.BigInteger;
import java.time.Instant;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.function.Function;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

public class SolanaEventClient implements EventFetcher {
    private final SolanaProvider provider;

    public SolanaEventClient(SolanaProvider provider) {
        this.provider = provider;
    }

    @Override
    public Flux<TxnEvent> events(String address, long startTimestamp) {
        var epochSecond = Instant.ofEpochMilli(startTimestamp).getEpochSecond();

        return getSignatures(address, epochSecond)
                .flatMap(this::fetchTransactionData)
                .collectList()
                .flatMapMany(list -> processTransactions(address, list));
    }

    private Flux<TransactionSignature> getSignatures(String address, long startTimestamp) {
        return Mono.fromCallable(() ->provider.getClient().getSignaturesForAddress(address))
                .flatMap(RpcResult::mono)
                .flatMapIterable(Function.identity())
                .takeWhile(tx -> tx.getBlockTime() >= startTimestamp);
    }

    private Mono<TransactionData> fetchTransactionData(TransactionSignature signature) {
        var txid = signature.getSignature();
        var memo = signature.getMemo();
        var time = signature.getBlockTime();

        return Mono.fromCallable(() -> provider.getClient().getTransaction(txid))
                .flatMap(RpcResult::mono)
                .map(tx -> new TransactionData(txid, memo, time, tx));
    }

    private Flux<TxnEvent> processTransactions(String address, List<TransactionData> list) {
        var txids = list.stream().map(data -> data.txid).toList();

        return Mono.fromCallable(() -> provider.getClient().getSignatureStatus(txids))
                .map(result -> result.getResult().getValue())
                .flatMapIterable(statuses -> mapLists(list, statuses).entrySet())
                .flatMap(entry -> createEvents(address, entry));
    }

    private Flux<TxnEvent> createEvents(String address, Map.Entry<TransactionData, SignatureStatuses.SignatureStatus> entry) {
        var data = entry.getKey();
        var status = entry.getValue();

        var instructions = data.getTx().getTransaction()
                .getMessage()
                .getInstructions()
                .stream()
                .filter(instruction -> instruction.getParsed().getType().equalsIgnoreCase("transfer"))
                .toList();

        var events = new ArrayList<TxnEvent>();

        for (var instruction : instructions) {
            var transferNode = instruction.getParsed().getInfo();
            events.add(buildEvent(address, transferNode, data, status));
        }

        return Flux.fromIterable(events);
    }

    private TxnEvent buildEvent(
            String address, JsonNode transferNode, TransactionData tx,
            SignatureStatuses.SignatureStatus status
    ) {
        var transfer = Jackson.convert(transferNode, Transaction.TransactionData.Transfer.class);
        var from = transfer.getSource();

        var type = from.equalsIgnoreCase(address) ? TxType.SEND : TxType.RECEIVE;

        var lamports = BigInteger.valueOf(transfer.getLamports());
        var humanAmount = provider.converter().toHuman(lamports);

        var value = new Value(humanAmount, lamports);
        var confirmations = Optional.ofNullable(status.getConfirmations()).orElse(32);

        return TxnEvent.builder()
                .asset(Asset.SOL)
                .type(type)
                .txid(tx.txid)
                .timestamp(Instant.ofEpochSecond(tx.timestamp).toEpochMilli())
                .memo(tx.memo)
                .confirmations(confirmations)
                .value(value)
                .build();
    }

    private static <K,V> Map<K, V> mapLists(List<K> txids, List<V> statuses) {
        return IntStream.range(0, txids.size())
                .boxed()
                .collect(Collectors.toMap(txids::get, statuses::get));
    }

    @Data
    @AllArgsConstructor
    private static class TransactionData {
        private String txid;
        private String memo;
        private long timestamp;
        private Transaction tx;
    }
}
